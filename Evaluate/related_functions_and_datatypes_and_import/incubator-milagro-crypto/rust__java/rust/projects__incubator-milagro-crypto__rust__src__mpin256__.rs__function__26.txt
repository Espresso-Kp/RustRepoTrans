pub fn equals(&self, a: &FP) -> bool {
        let mut f = self.clone();
        let mut s = a.clone();
        f.reduce();
        s.reduce();
        if Big::comp(&(f.x), &(s.x)) == 0 {
            return true;
        }
        return false;
    }

pub fn geta(&self) -> FP2 {
        self.a.clone()
    }

pub fn conj(&mut self) {
        self.b.neg();
        self.norm();
    }

pub fn usqr(&mut self) {
        let mut a = self.geta();
        let mut b = self.getc();
        let mut c = self.getb();

        self.a.sqr();
        let mut d = self.geta();
        d.add(&self.a);
        self.a.add(&d);

        self.a.norm();
        a.nconj();

        a.dbl();
        self.a.add(&a);
        b.sqr();
        b.times_i();

        d = b.clone();
        d.add(&b);
        b.add(&d);
        b.norm();

        c.sqr();
        d = c.clone();
        d.add(&c);
        c.add(&d);
        c.norm();

        self.b.conj();
        self.b.dbl();
        self.c.nconj();

        self.c.dbl();
        self.b.add(&b);
        self.c.add(&c);
        self.stype = DENSE;
        self.reduce();
    }

pub fn mul(&mut self, b: &FP) {
        if i64::from(self.xes) * i64::from(b.xes) > i64::from(FEXCESS) {
            self.reduce()
        }

        let mut d = Big::mul(&(self.x), &(b.x));
        self.x = FP::modulo(&mut d);
        self.xes = 2;
    }

pub fn one(&mut self) {
        self.x.one();
        self.nres()
    }

pub fn from_bytes(w: &[u8]) -> FP48 {
        let mut t: [u8; big::MODBYTES as usize] = [0; big::MODBYTES as usize];
        let mb = big::MODBYTES as usize;

        for i in 0..mb {
            t[i] = w[i]
        }
        let a = Big::from_bytes(&t);
        for i in 0..mb {
            t[i] = w[i + mb]
        }
        let b = Big::from_bytes(&t);
        let c = FP2::new_bigs(a, b);

        for i in 0..mb {
            t[i] = w[i + 2 * mb]
        }
        let a = Big::from_bytes(&t);
        for i in 0..mb {
            t[i] = w[i + 3 * mb]
        }
        let b = Big::from_bytes(&t);
        let d = FP2::new_bigs(a, b);

        let ea = FP4::new_fp2s(c, d);

        for i in 0..mb {
            t[i] = w[i + 4 * mb]
        }
        let a = Big::from_bytes(&t);
        for i in 0..mb {
            t[i] = w[i + 5 * mb]
        }
        let b = Big::from_bytes(&t);
        let c = FP2::new_bigs(a, b);

        for i in 0..mb {
            t[i] = w[i + 6 * mb]
        }
        let a = Big::from_bytes(&t);
        for i in 0..mb {
            t[i] = w[i + 7 * mb]
        }
        let b = Big::from_bytes(&t);
        let d = FP2::new_bigs(a, b);

        let eb = FP4::new_fp2s(c, d);

        let ea8 = FP8::new_fp4s(ea, eb);

        for i in 0..mb {
            t[i] = w[i + 8 * mb]
        }
        let a = Big::from_bytes(&t);
        for i in 0..mb {
            t[i] = w[i + 9 * mb]
        }
        let b = Big::from_bytes(&t);
        let c = FP2::new_bigs(a, b);

        for i in 0..mb {
            t[i] = w[i + 10 * mb]
        }
        let a = Big::from_bytes(&t);
        for i in 0..mb {
            t[i] = w[i + 11 * mb]
        }
        let b = Big::from_bytes(&t);
        let d = FP2::new_bigs(a, b);

        let ea = FP4::new_fp2s(c, d);

        for i in 0..mb {
            t[i] = w[i + 12 * mb]
        }
        let a = Big::from_bytes(&t);
        for i in 0..mb {
            t[i] = w[i + 13 * mb]
        }
        let b = Big::from_bytes(&t);
        let c = FP2::new_bigs(a, b);

        for i in 0..mb {
            t[i] = w[i + 14 * mb]
        }
        let a = Big::from_bytes(&t);
        for i in 0..mb {
            t[i] = w[i + 15 * mb]
        }
        let b = Big::from_bytes(&t);
        let d = FP2::new_bigs(a, b);

        let eb = FP4::new_fp2s(c, d);

        let eb8 = FP8::new_fp4s(ea, eb);

        let e = FP16::new_fp8s(ea8, eb8);

        for i in 0..mb {
            t[i] = w[i + 16 * mb]
        }
        let a = Big::from_bytes(&t);
        for i in 0..mb {
            t[i] = w[i + 17 * mb]
        }
        let b = Big::from_bytes(&t);
        let c = FP2::new_bigs(a, b);

        for i in 0..mb {
            t[i] = w[i + 18 * mb]
        }
        let a = Big::from_bytes(&t);
        for i in 0..mb {
            t[i] = w[i + 19 * mb]
        }
        let b = Big::from_bytes(&t);
        let d = FP2::new_bigs(a, b);

        let ea = FP4::new_fp2s(c, d);

        for i in 0..mb {
            t[i] = w[i + 20 * mb]
        }
        let a = Big::from_bytes(&t);
        for i in 0..mb {
            t[i] = w[i + 21 * mb]
        }
        let b = Big::from_bytes(&t);
        let c = FP2::new_bigs(a, b);

        for i in 0..mb {
            t[i] = w[i + 22 * mb]
        }
        let a = Big::from_bytes(&t);
        for i in 0..mb {
            t[i] = w[i + 23 * mb]
        }
        let b = Big::from_bytes(&t);
        let d = FP2::new_bigs(a, b);

        let eb = FP4::new_fp2s(c, d);

        let ea8 = FP8::new_fp4s(ea, eb);

        for i in 0..mb {
            t[i] = w[i + 24 * mb]
        }
        let a = Big::from_bytes(&t);
        for i in 0..mb {
            t[i] = w[i + 25 * mb]
        }
        let b = Big::from_bytes(&t);
        let c = FP2::new_bigs(a, b);

        for i in 0..mb {
            t[i] = w[i + 26 * mb]
        }
        let a = Big::from_bytes(&t);
        for i in 0..mb {
            t[i] = w[i + 27 * mb]
        }
        let b = Big::from_bytes(&t);
        let d = FP2::new_bigs(a, b);

        let ea = FP4::new_fp2s(c, d);

        for i in 0..mb {
            t[i] = w[i + 28 * mb]
        }
        let a = Big::from_bytes(&t);
        for i in 0..mb {
            t[i] = w[i + 29 * mb]
        }
        let b = Big::from_bytes(&t);
        let c = FP2::new_bigs(a, b);

        for i in 0..mb {
            t[i] = w[i + 30 * mb]
        }
        let a = Big::from_bytes(&t);
        for i in 0..mb {
            t[i] = w[i + 31 * mb]
        }
        let b = Big::from_bytes(&t);
        let d = FP2::new_bigs(a, b);

        let eb = FP4::new_fp2s(c, d);

        let eb8 = FP8::new_fp4s(ea, eb);

        let f = FP16::new_fp8s(ea8, eb8);

        for i in 0..mb {
            t[i] = w[i + 32 * mb]
        }
        let a = Big::from_bytes(&t);
        for i in 0..mb {
            t[i] = w[i + 33 * mb]
        }
        let b = Big::from_bytes(&t);
        let c = FP2::new_bigs(a, b);

        for i in 0..mb {
            t[i] = w[i + 34 * mb]
        }
        let a = Big::from_bytes(&t);
        for i in 0..mb {
            t[i] = w[i + 35 * mb]
        }
        let b = Big::from_bytes(&t);
        let d = FP2::new_bigs(a, b);

        let ea = FP4::new_fp2s(c, d);

        for i in 0..mb {
            t[i] = w[i + 36 * mb]
        }
        let a = Big::from_bytes(&t);
        for i in 0..mb {
            t[i] = w[i + 37 * mb]
        }
        let b = Big::from_bytes(&t);
        let c = FP2::new_bigs(a, b);

        for i in 0..mb {
            t[i] = w[i + 38 * mb]
        }
        let a = Big::from_bytes(&t);
        for i in 0..mb {
            t[i] = w[i + 39 * mb]
        }
        let b = Big::from_bytes(&t);
        let d = FP2::new_bigs(a, b);

        let eb = FP4::new_fp2s(c, d);

        let ea8 = FP8::new_fp4s(ea, eb);

        for i in 0..mb {
            t[i] = w[i + 40 * mb]
        }
        let a = Big::from_bytes(&t);
        for i in 0..mb {
            t[i] = w[i + 41 * mb]
        }
        let b = Big::from_bytes(&t);

        let c = FP2::new_bigs(a, b);

        for i in 0..mb {
            t[i] = w[i + 42 * mb]
        }
        let a = Big::from_bytes(&t);
        for i in 0..mb {
            t[i] = w[i + 43 * mb]
        }
        let b = Big::from_bytes(&t);
        let d = FP2::new_bigs(a, b);

        let ea = FP4::new_fp2s(c, d);

        for i in 0..mb {
            t[i] = w[i + 44 * mb]
        }
        let a = Big::from_bytes(&t);
        for i in 0..mb {
            t[i] = w[i + 45 * mb]
        }
        let b = Big::from_bytes(&t);

        let c = FP2::new_bigs(a, b);

        for i in 0..mb {
            t[i] = w[i + 46 * mb]
        }
        let a = Big::from_bytes(&t);
        for i in 0..mb {
            t[i] = w[i + 47 * mb]
        }
        let b = Big::from_bytes(&t);
        let d = FP2::new_bigs(a, b);

        let eb = FP4::new_fp2s(c, d);

        let eb8 = FP8::new_fp4s(ea, eb);

        let g = FP16::new_fp8s(ea8, eb8);

        return FP48::new_fp16s(e, f, g);
    }


pub fn lastbits(&mut self, n: usize) -> isize {
        let msk = ((1 << n) - 1) as Chunk;
        self.norm();
        (self.w[0] & msk) as isize
    }

pub struct FP48 {
    a: FP16,
    b: FP16,
    c: FP16,
    stype: usize,
}

pub const MAXPIN: i32 = 10000; // PIN less than this

pub const TS: usize = 10; 

pub const TRAP: usize = 200; // 200 for 4 digit PIN, 2000 for 6-digit PIN  - approx 2*sqrt(MAXPIN)


------
use std::time::SystemTime;
use std::time::UNIX_EPOCH;
use super::big;
use super::big::Big;
use super::ecp;
use super::ecp::ECP;
use super::ecp8::ECP8;
use super::fp16::FP16;
use super::fp48::FP48;
use super::pair256;
use super::rom;
use crate::hash256::HASH256;
use crate::hash384::HASH384;
use crate::hash512::HASH512;
use crate::rand::RAND;
use super::*;
use crate::test_utils::*;
