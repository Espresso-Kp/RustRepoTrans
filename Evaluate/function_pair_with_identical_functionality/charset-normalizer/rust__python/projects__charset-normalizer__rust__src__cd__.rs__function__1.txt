<path>
projects/charset-normalizer/rust/src/cd.rs
</path>
<function>
pub(crate) fn encoding_unicode_range(iana_name: &str) -> Result<Vec<&str>, String> {
    if is_multi_byte_encoding(iana_name) {
        return Err("Function not supported on multi-byte code page".to_string());
    }
    let encoder = encoding_from_whatwg_label(iana_name)
        .ok_or("No decoder found for this encoding".to_string())?;

    let byte_range = 0x40..0xFF; // utf8 range. range.len()==191
    let mut result: HashMap<&str, u8> = HashMap::with_capacity(byte_range.len());

    byte_range.for_each(|i| {
        if let Some(range) = encoder
            .decode(&[i], DecoderTrap::Ignore)
            .ok()
            .and_then(|chunk| chunk.chars().next())
            .and_then(unicode_range)
            .filter(|&range| !is_unicode_range_secondary(range))
        {
            *result.entry(range).or_insert(0) += 1;
        }
    });
    let character_count: u8 = result.values().sum();
    let threshold = 0.15;
    let mut result: Vec<&str> = result
        .iter()
        .filter(|(_, &value)| (value as f32 / character_count as f32) >= threshold)
        .map(|(&name, _)| name)
        .collect();
    result.sort_unstable();
    Ok(result)
}
</function>
------

<path>
projects/charset-normalizer/python/cd.py
</path>
<function>
def encoding_unicode_range(iana_name: str) -> List[str]:
    """
    Return associated unicode ranges in a single byte code page.
    """
    if is_multi_byte_encoding(iana_name):
        raise IOError("Function not supported on multi-byte code page")

    decoder = importlib.import_module(
        "encodings.{}".format(iana_name)
    ).IncrementalDecoder

    p: IncrementalDecoder = decoder(errors="ignore")
    seen_ranges: Dict[str, int] = {}
    character_count: int = 0

    for i in range(0x40, 0xFF):
        chunk: str = p.decode(bytes([i]))

        if chunk:
            character_range: Optional[str] = unicode_range(chunk)

            if character_range is None:
                continue

            if is_unicode_range_secondary(character_range) is False:
                if character_range not in seen_ranges:
                    seen_ranges[character_range] = 0
                seen_ranges[character_range] += 1
                character_count += 1

    return sorted(
        [
            character_range
            for character_range in seen_ranges
            if seen_ranges[character_range] / character_count >= 0.15
        ]
    )


</function>
