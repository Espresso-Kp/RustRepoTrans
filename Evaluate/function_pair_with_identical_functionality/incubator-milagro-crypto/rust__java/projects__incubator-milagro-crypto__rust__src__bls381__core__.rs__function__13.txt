<path>
projects/incubator-milagro-crypto/rust/src/bls381/core.rs
</path>
<function>
pub fn serialize_uncompressed_g2(g2: &ECP2) -> [u8; G2_BYTES * 2] {
    let mut result = [0; G2_BYTES * 2];

    // Check point at inifinity
    if g2.is_infinity() {
        result[0] += INFINITY_FLAG;
        return result;
    }

    // Convert to bytes
    // Note: Zcash uses (x_im, x_re), (y_im, y_re)
    let x = g2.getx();
    x.getb().to_bytes(&mut result[0..MODBYTES]);
    x.geta().to_bytes(&mut result[MODBYTES..(MODBYTES * 2)]);
    let x = g2.gety();
    x.getb()
        .to_bytes(&mut result[(MODBYTES * 2)..(MODBYTES * 3)]);
    x.geta().to_bytes(&mut result[(MODBYTES * 3)..]);

    result
}
</function>
------

<path>
projects/incubator-milagro-crypto/java/src/main/java/org/apache/milagro/amcl/BLS383/ECP2.java
</path>
<function>
public void toBytes(byte[] b)
	{
		byte[] t=new byte[BIG.MODBYTES];
		ECP2 W=new ECP2(this);
		W.affine();
		W.x.getA().toBytes(t);
		for (int i=0;i<BIG.MODBYTES;i++)
			b[i]=t[i];
		W.x.getB().toBytes(t);
		for (int i=0;i<BIG.MODBYTES;i++)
			b[i+BIG.MODBYTES]=t[i];

		W.y.getA().toBytes(t);
		for (int i=0;i<BIG.MODBYTES;i++)
			b[i+2*BIG.MODBYTES]=t[i];
		W.y.getB().toBytes(t);
		for (int i=0;i<BIG.MODBYTES;i++)
			b[i+3*BIG.MODBYTES]=t[i];
	}
</function>

