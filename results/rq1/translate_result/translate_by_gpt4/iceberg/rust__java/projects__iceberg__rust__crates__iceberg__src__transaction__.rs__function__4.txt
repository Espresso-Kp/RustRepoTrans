<message>
please translate the given java function to rust according to the rust function signature, rust function dependencies(including function and variable dependencies), and data type declarations and rust function dependency libraries I provide(delimited with XML tags).Please make sure to call the relevant dependencies as much as possible in the translated function Only response the translated function results.
<java function>
public Builder upgradeFormatVersion(int newFormatVersion) {
      Preconditions.checkArgument(
          newFormatVersion <= SUPPORTED_TABLE_FORMAT_VERSION,
          "Cannot upgrade table to unsupported format version: v%s (supported: v%s)",
          newFormatVersion,
          SUPPORTED_TABLE_FORMAT_VERSION);
      Preconditions.checkArgument(
          newFormatVersion >= formatVersion,
          "Cannot downgrade v%s table to v%s",
          formatVersion,
          newFormatVersion);

      if (newFormatVersion == formatVersion) {
        return this;
      }

      this.formatVersion = newFormatVersion;
      changes.add(new MetadataUpdate.UpgradeFormatVersion(newFormatVersion));

      return this;
    }
</java function>
<rust function signature>
pub fn upgrade_table_version(mut self, format_version: FormatVersion) -> Result<Self> 
</rust function signature>
<rust function dependencies, and data type declarations>
pub async fn metadata(&self) -> Result<FileMetadata> {
        let meta = self.op.stat(&self.path[self.relative_path_pos..]).await?;

        Ok(FileMetadata {
            size: meta.content_length(),
        })
    }

fn append_updates(&mut self, updates: Vec<TableUpdate>) -> Result<()> {
        for update in &updates {
            for up in &self.updates {
                if discriminant(up) == discriminant(update) {
                    return Err(Error::new(
                        ErrorKind::DataInvalid,
                        format!(
                            "Cannot apply update with same type at same time: {:?}",
                            update
                        ),
                    ));
                }
            }
        }
        self.updates.extend(updates);
        Ok(())
    }

pub fn new(kind: ErrorKind, message: impl Into<String>) -> Self {
        Self {
            kind,
            message: message.into(),
            context: Vec::default(),

            source: None,
            // `Backtrace::capture()` will check if backtrace has been enabled
            // internally. It's zero cost if backtrace is disabled.
            backtrace: Backtrace::capture(),
        }
    }

pub struct Transaction<'a> {
    table: &'a Table,
    updates: Vec<TableUpdate>,
    requirements: Vec<TableRequirement>,
}

pub enum Ordering {
    /// An ordering where a compared value is less than another.
    #[stable(feature = "rust1", since = "1.0.0")]
    Less = -1,
    /// An ordering where a compared value is equal to another.
    #[stable(feature = "rust1", since = "1.0.0")]
    Equal = 0,
    /// An ordering where a compared value is greater than another.
    #[stable(feature = "rust1", since = "1.0.0")]
    Greater = 1,
}

pub enum ErrorKind {
    /// Iceberg don't know what happened here, and no actions other than
    /// just returning it back. For example, iceberg returns an internal
    /// service error.
    Unexpected,

    /// Iceberg data is invalid.
    ///
    /// This error is returned when we try to read a table from iceberg but
    /// failed to parse it's metadata or data file correctly.
    ///
    /// The table could be invalid or corrupted.
    DataInvalid,
    /// Iceberg feature is not supported.
    ///
    /// This error is returned when given iceberg feature is not supported.
    FeatureUnsupported,
}

pub struct Error {
    kind: ErrorKind,
    message: String,

    context: Vec<(&'static str, String)>,

    source: Option<anyhow::Error>,
    backtrace: Backtrace,
}

pub enum TableUpdate {
    /// Upgrade table's format version
    #[serde(rename_all = "kebab-case")]
    UpgradeFormatVersion {
        /// Target format upgrade to.
        format_version: FormatVersion,
    },
    /// Assign a new UUID to the table
    #[serde(rename_all = "kebab-case")]
    AssignUuid {
        /// The new UUID to assign.
        uuid: Uuid,
    },
    /// Add a new schema to the table
    #[serde(rename_all = "kebab-case")]
    AddSchema {
        /// The schema to add.
        schema: Schema,
        /// The last column id of the table.
        last_column_id: Option<i32>,
    },
    /// Set table's current schema
    #[serde(rename_all = "kebab-case")]
    SetCurrentSchema {
        /// Schema ID to set as current, or -1 to set last added schema
        schema_id: i32,
    },
    /// Add a new partition spec to the table
    AddSpec {
        /// The partition spec to add.
        spec: UnboundPartitionSpec,
    },
    /// Set table's default spec
    #[serde(rename_all = "kebab-case")]
    SetDefaultSpec {
        /// Partition spec ID to set as the default, or -1 to set last added spec
        spec_id: i32,
    },
    /// Add sort order to table.
    #[serde(rename_all = "kebab-case")]
    AddSortOrder {
        /// Sort order to add.
        sort_order: SortOrder,
    },
    /// Set table's default sort order
    #[serde(rename_all = "kebab-case")]
    SetDefaultSortOrder {
        /// Sort order ID to set as the default, or -1 to set last added sort order
        sort_order_id: i64,
    },
    /// Add snapshot to table.
    #[serde(rename_all = "kebab-case")]
    AddSnapshot {
        /// Snapshot to add.
        snapshot: Snapshot,
    },
    /// Set table's snapshot ref.
    #[serde(rename_all = "kebab-case")]
    SetSnapshotRef {
        /// Name of snapshot reference to set.
        ref_name: String,
        /// Snapshot reference to set.
        #[serde(flatten)]
        reference: SnapshotReference,
    },
    /// Remove table's snapshots
    #[serde(rename_all = "kebab-case")]
    RemoveSnapshots {
        /// Snapshot ids to remove.
        snapshot_ids: Vec<i64>,
    },
    /// Remove snapshot reference
    #[serde(rename_all = "kebab-case")]
    RemoveSnapshotRef {
        /// Name of snapshot reference to remove.
        ref_name: String,
    },
    /// Update table's location
    SetLocation {
        /// New location for table.
        location: String,
    },
    /// Update table's properties
    SetProperties {
        /// Properties to update for table.
        updates: HashMap<String, String>,
    },
    /// Remove table's properties
    RemoveProperties {
        /// Properties to remove
        removals: Vec<String>,
    },
}


</rust function dependencies, and data type declarations>
<rust function dependency libraries>
use crate::error::Result;
use crate::spec::{FormatVersion, NullOrder, SortDirection, SortField, SortOrder, Transform};
use crate::table::Table;
use crate::TableUpdate::UpgradeFormatVersion;
use crate::{Catalog, Error, ErrorKind, TableCommit, TableRequirement, TableUpdate};
use std::cmp::Ordering;
use std::collections::HashMap;
use std::mem::discriminant;
use crate::io::FileIO;
use crate::spec::{FormatVersion, TableMetadata};
use crate::table::Table;
use crate::transaction::Transaction;
use crate::{TableIdent, TableRequirement, TableUpdate};
use std::collections::HashMap;
use std::fs::File;
use std::io::BufReader;

</rust function dependency libraries>

</message>
<function>
pub fn upgrade_table_version(mut self, format_version: FormatVersion) -> Result<Self> {
        let current_version = self.table.metadata().format_version();
        match current_version.cmp(&format_version) {
            Ordering::Greater => {
                return Err(Error::new(
                    ErrorKind::DataInvalid,
                    format!(
                        "Cannot downgrade table version from {} to {}",
                        current_version, format_version
                    ),
                ));
            }
            Ordering::Less => {
                self.append_updates(vec![UpgradeFormatVersion { format_version }])?;
            }
            Ordering::Equal => {
                // Do nothing.
            }
        }
        Ok(self)
    }
</function>
<translated function>
Here is the equivalent Rust function, it writes out a basic translation:

```rust
pub fn upgrade_table_version(mut self, new_format_version: FormatVersion) -> Result<Self> {
    let supported_format_version = FormatVersion; // Assuming the supported_format_version value should come from a constant. The constant should ideally be defined on FormatVersion enum.
    match new_format_version.cmp(&format_version) {
        Ordering::Greater => if new_format_version > supported_format_version {
            return Err(Error::new(ErrorKind::DataInvalid, 
                format!("Cannot upgrade table to unsupported format version: v{:?} (supported: v{:?})", new_format_version, supported_format_version))
            ),
            
        Ordering::Less => return Err(Error::new(ErrorKind::DataInvalid, 
            format!("Cannot downgrade v{:?} table to v{:?}", format_version, new_format_version)
        )),

        Ordering::Equal => return Ok(self),
    }

    self.format_version = new_format_version;
    let table_update = TableUpdate::UpgradeFormatVersion { format_version: new_format_version};
    match self.append_updates(vec![table_update]) {
        Err(e) => Err(e),
        Ok(()) => Ok(self)
    }
}
```

This function basically takes the `FormatVersion` of the new table as an argument and checks whether we can upgrade or downgrade to it based on its comparison with the current `FormatVersion`.
If the new `FormatVersion` is supported and it's not the current `FormatVersion`, then the function updates `formatVersion` and appends the new `TableUpdate::UpgradeFormatVersion` to the list of table updates. If either of the checks fails, then an error is returned.</translated function>Here is the equivalent Rust function, it writes out a basic translation:

```rust
pub fn upgrade_table_version(mut self, new_format_version: FormatVersion) -> Result<Self> {
    let supported_format_version = FormatVersion; // Assuming the supported_format_version value should come from a constant. The constant should ideally be defined on FormatVersion enum.
    match new_format_version.cmp(&format_version) {
        Ordering::Greater => if new_format_version > supported_format_version {
            return Err(Error::new(ErrorKind::DataInvalid, 
                format!("Cannot upgrade table to unsupported format version: v{:?} (supported: v{:?})", new_format_version, supported_format_version))
            ),
            
        Ordering::Less => return Err(Error::new(ErrorKind::DataInvalid, 
            format!("Cannot downgrade v{:?} table to v{:?}", format_version, new_format_version)
        )),

        Ordering::Equal => return Ok(self),
    }

    self.format_version = new_format_version;
    let table_update = TableUpdate::UpgradeFormatVersion { format_version: new_format_version};
    match self.append_updates(vec![table_update]) {
        Err(e) => Err(e),
        Ok(()) => Ok(self)
    }
}
```

This function basically takes the `FormatVersion` of the new table as an argument and checks whether we can upgrade or downgrade to it based on its comparison with the current `FormatVersion`.
If the new `FormatVersion` is supported and it's not the current `FormatVersion`, then the function updates `formatVersion` and appends the new `TableUpdate::UpgradeFormatVersion` to the list of table updates. If either of the checks fails, then an error is returned.