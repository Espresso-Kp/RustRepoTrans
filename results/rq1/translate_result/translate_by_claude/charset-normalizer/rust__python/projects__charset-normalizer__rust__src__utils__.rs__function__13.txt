<message>
please translate the given python function to rust according to the rust function signature, rust function dependencies(including function and variable dependencies), and data type declarations and rust function dependency libraries I provide(delimited with XML tags).Please make sure to call the relevant dependencies as much as possible in the translated function Only response the translated function results.
<python function>
def cp_similarity(iana_name_a: str, iana_name_b: str) -> float:
    if is_multi_byte_encoding(iana_name_a) or is_multi_byte_encoding(iana_name_b):
        return 0.0

    decoder_a = importlib.import_module(
        "encodings.{}".format(iana_name_a)
    ).IncrementalDecoder
    decoder_b = importlib.import_module(
        "encodings.{}".format(iana_name_b)
    ).IncrementalDecoder

    id_a: IncrementalDecoder = decoder_a(errors="ignore")
    id_b: IncrementalDecoder = decoder_b(errors="ignore")

    character_match_count: int = 0

    for i in range(255):
        to_be_decoded: bytes = bytes([i])
        if id_a.decode(to_be_decoded) == id_b.decode(to_be_decoded):
            character_match_count += 1

    return character_match_count / 254
</python function>
<rust function signature>
pub(crate) fn cp_similarity(iana_name_a: &str, iana_name_b: &str) -> f32 
</rust function signature>
<rust function dependencies, and data type declarations>
pub fn decode(
    input: &[u8],
    from_encoding: &str,
    how_process_errors: DecoderTrap,
    only_test: bool,
    is_chunk: bool,
) -> Result<String, String> {
    let encoder = encoding_from_whatwg_label(from_encoding)
        .ok_or(format!("Encoding '{}' not found", from_encoding))?;

    let mut buf = DecodeTestResult {
        only_test,
        data: String::new(),
    };
    let mut err = CodecError {
        upto: 0,
        cause: Cow::from(String::new()),
    };
    let chunk_len = input.len();
    let mut begin_offset: usize = 0;
    let mut end_offset: usize = chunk_len;
    let mut error_occured: bool;
    loop {
        let res = decode_to(
            encoder,
            &input[begin_offset..end_offset],
            how_process_errors,
            &mut buf,
        );
        error_occured = res.is_err();
        if let DecoderTrap::Strict = how_process_errors {
            if !is_chunk || res.is_ok() || !is_multi_byte_encoding(from_encoding) {
                break;
            }
            err = res.unwrap_err();
            if err.cause.contains("invalid sequence") {
                begin_offset += 1;
            } else if err.cause.contains("incomplete sequence") {
                end_offset -= 1;
            }
            if end_offset - begin_offset < 1 || begin_offset > 3 || (chunk_len - end_offset) > 3 {
                break;
            }
        } else {
            break;
        }
    }
    if error_occured {
        return Err(format!("{} at index {}", err.cause, err.upto));
    }
    Ok(String::from(buf.get_buffer()))
}

pub fn is_multi_byte_encoding(name: &str) -> bool {
    [
        "utf-8",
        "utf-16le",
        "utf-16be",
        "euc-jp",
        "euc-kr",
        "iso-2022-jp",
        "gbk",
        "gb18030",
        "hz",
        "big5",
        "shift_jis",
    ]
    .contains(&name)
}


</rust function dependencies, and data type declarations>
<rust function dependency libraries>
use crate::assets::LANGUAGES;
use crate::consts::{
    ENCODING_MARKS, IANA_SUPPORTED, IANA_SUPPORTED_SIMILAR, RE_POSSIBLE_ENCODING_INDICATION,
    UNICODE_RANGES_COMBINED, UNICODE_SECONDARY_RANGE_KEYWORD,
};
use crate::entity::Language;
use ahash::{HashSet, HashSetExt};
use encoding::label::encoding_from_whatwg_label;
use encoding::{CodecError, DecoderTrap, EncoderTrap, Encoding, EncodingRef, StringWriter};
use icu_normalizer::DecomposingNormalizer;
use unicode_names2::name;
use std::borrow::Cow;
use std::fs;
use std::path::{Path, PathBuf};

</rust function dependency libraries>

</message>
<function>
pub(crate) fn cp_similarity(iana_name_a: &str, iana_name_b: &str) -> f32 {
    // we don't want to compare multi-byte encodings
    if is_multi_byte_encoding(iana_name_a) || is_multi_byte_encoding(iana_name_b) {
        return 0.0;
    }

    if let (Some(encoder_a), Some(encoder_b)) = (
        encoding_from_whatwg_label(iana_name_a),
        encoding_from_whatwg_label(iana_name_b),
    ) {
        let character_match_count = (1..255u8)
            .filter(|&ch| {
                let res_a = encoder_a.decode(&[ch], DecoderTrap::Ignore).ok();
                let res_b = encoder_b.decode(&[ch], DecoderTrap::Ignore).ok();
                res_a.is_some() && res_a == res_b //check that they aren't none and equal
            })
            .count();
        return character_match_count as f32 / 254.0;
    }
    0.0 // Return 0.0 if encoders could not be retrieved.
}
</function>
<translated function>
Here's the translated Rust function based on the provided Python function and Rust-specific information:

```rust
pub(crate) fn cp_similarity(iana_name_a: &str, iana_name_b: &str) -> f32 {
    if is_multi_byte_encoding(iana_name_a) || is_multi_byte_encoding(iana_name_b) {
        return 0.0;
    }

    let encoder_a = encoding_from_whatwg_label(iana_name_a)
        .expect("Encoding not found");
    let encoder_b = encoding_from_whatwg_label(iana_name_b)
        .expect("Encoding not found");

    let mut character_match_count = 0;

    for i in 0..=255 {
        let to_be_decoded = vec![i];
        let decoded_a = decode(&to_be_decoded, iana_name_a, DecoderTrap::Ignore, false, false)
            .expect("Decoding failed");
        let decoded_b = decode(&to_be_decoded, iana_name_b, DecoderTrap::Ignore, false, false)
            .expect("Decoding failed");

        if decoded_a == decoded_b {
            character_match_count += 1;
        }
    }

    character_match_count as f32 / 254.0
}
```

This Rust function follows the provided signature and uses the available functions and types from the given declarations. It maintains the same logic as the Python function but adapts it to Rust's syntax and conventions.</translated function>Here's the translated Rust function based on the provided Python function and Rust-specific information:

```rust
pub(crate) fn cp_similarity(iana_name_a: &str, iana_name_b: &str) -> f32 {
    if is_multi_byte_encoding(iana_name_a) || is_multi_byte_encoding(iana_name_b) {
        return 0.0;
    }

    let encoder_a = encoding_from_whatwg_label(iana_name_a)
        .expect("Encoding not found");
    let encoder_b = encoding_from_whatwg_label(iana_name_b)
        .expect("Encoding not found");

    let mut character_match_count = 0;

    for i in 0..=255 {
        let to_be_decoded = vec![i];
        let decoded_a = decode(&to_be_decoded, iana_name_a, DecoderTrap::Ignore, false, false)
            .expect("Decoding failed");
        let decoded_b = decode(&to_be_decoded, iana_name_b, DecoderTrap::Ignore, false, false)
            .expect("Decoding failed");

        if decoded_a == decoded_b {
            character_match_count += 1;
        }
    }

    character_match_count as f32 / 254.0
}
```

This Rust function follows the provided signature and uses the available functions and types from the given declarations. It maintains the same logic as the Python function but adapts it to Rust's syntax and conventions.