Fail
file path is :
projects/deltachat-core/rust/src/contact.rs

output is:


error is :
   Compiling deltachat v1.139.6 (/home/k/ogs_PHD/LLM4SE/2Rust_projects/auto_get_functionPair/projects/deltachat-core/rust)
error[E0425]: cannot find value `DC_CONTACT_MAGIC` in this scope
    --> src/contact.rs:1313:39
     |
1313 |     if self.is_none() || self.magic!= DC_CONTACT_MAGIC {
     |                                       ^^^^^^^^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
    --> src/chat.rs:2536:55
     |
2536 |         let peerstate = Peerstate::from_addr(context, contact.get_addr()).await?;
     |                         --------------------          ^^^^^^^^^^^^^^^^^^ expected `&str`, found `Option<&str>`
     |                         |
     |                         arguments to this function are incorrect
     |
     = note: expected reference `&str`
                     found enum `std::option::Option<&str>`
note: associated function defined here
    --> src/peerstate.rs:170:18
     |
170  |     pub async fn from_addr(context: &Context, addr: &str) -> Result<Option<Peerstate>> {
     |                  ^^^^^^^^^                    ----------
help: consider using `Option::expect` to unwrap the `std::option::Option<&str>` value, panicking if the value is an `Option::None`
     |
2536 |         let peerstate = Peerstate::from_addr(context, contact.get_addr().expect("REASON")).await?;
     |                                                                         +++++++++++++++++

error[E0599]: the method `to_string` exists for enum `Option<&str>`, but its trait bounds were not satisfied
    --> src/chat.rs:2183:69
     |
2183 |                     r = Some(SyncId::ContactAddr(contact.get_addr().to_string()));
     |                                                                     ^^^^^^^^^ method cannot be called on `Option<&str>` due to unsatisfied trait bounds
     |
    ::: /home/k/.rustup/toolchains/1.77.1-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:570:1
     |
570  | pub enum Option<T> {
     | ------------------ doesn't satisfy `std::option::Option<&str>: ToString` or `std::option::Option<&str>: std::fmt::Display`
     |
     = note: the following trait bounds were not satisfied:
             `std::option::Option<&str>: std::fmt::Display`
             which is required by `std::option::Option<&str>: ToString`
note: the method `to_string` exists on the type `&str`
    --> /home/k/.rustup/toolchains/1.77.1-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/string.rs:2589:5
     |
2589 |     fn to_string(&self) -> String;
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Option::expect` to unwrap the `&str` value, panicking if the value is an `Option::None`
     |
2183 |                     r = Some(SyncId::ContactAddr(contact.get_addr().expect("REASON").to_string()));
     |                                                                    +++++++++++++++++

error[E0308]: mismatched types
    --> src/chat.rs:1265:59
     |
1265 |             let peerstate = Peerstate::from_addr(context, addr).await?;
     |                             --------------------          ^^^^ expected `&str`, found `Option<&str>`
     |                             |
     |                             arguments to this function are incorrect
     |
     = note: expected reference `&str`
                     found enum `std::option::Option<&str>`
note: associated function defined here
    --> src/peerstate.rs:170:18
     |
170  |     pub async fn from_addr(context: &Context, addr: &str) -> Result<Option<Peerstate>> {
     |                  ^^^^^^^^^                    ----------
help: consider using `Option::expect` to unwrap the `std::option::Option<&str>` value, panicking if the value is an `Option::None`
     |
1265 |             let peerstate = Peerstate::from_addr(context, addr.expect("REASON")).await?;
     |                                                               +++++++++++++++++

error[E0277]: `std::option::Option<&str>` doesn't implement `std::fmt::Display`
    --> src/chat.rs:1271:76
     |
1271 |                 Some(EncryptPreference::Mutual) => ret_mutual += &format!("{addr}\n"),
     |                                                                            ^^^^^^ `std::option::Option<&str>` cannot be formatted with the default formatter
     |
     = help: the trait `std::fmt::Display` is not implemented for `std::option::Option<&str>`
     = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
     = note: this error originates in the macro `$crate::__export::format_args` which comes from the expansion of the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: `std::option::Option<&str>` doesn't implement `std::fmt::Display`
    --> src/chat.rs:1272:88
     |
1272 |                 Some(EncryptPreference::NoPreference) => ret_nopreference += &format!("{addr}\n"),
     |                                                                                        ^^^^^^ `std::option::Option<&str>` cannot be formatted with the default formatter
     |
     = help: the trait `std::fmt::Display` is not implemented for `std::option::Option<&str>`
     = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
     = note: this error originates in the macro `$crate::__export::format_args` which comes from the expansion of the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: `std::option::Option<&str>` doesn't implement `std::fmt::Display`
    --> src/chat.rs:1273:81
     |
1273 |                 Some(EncryptPreference::Reset) | None => ret_reset += &format!("{addr}\n"),
     |                                                                                 ^^^^^^ `std::option::Option<&str>` cannot be formatted with the default formatter
     |
     = help: the trait `std::fmt::Display` is not implemented for `std::option::Option<&str>`
     = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
     = note: this error originates in the macro `$crate::__export::format_args` which comes from the expansion of the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
    --> src/chat.rs:3727:29
     |
3727 |     if context.is_self_addr(contact.get_addr()).await? {
     |                ------------ ^^^^^^^^^^^^^^^^^^ expected `&str`, found `Option<&str>`
     |                |
     |                arguments to this method are incorrect
     |
     = note: expected reference `&str`
                     found enum `std::option::Option<&str>`
note: method defined here
    --> src/config.rs:721:25
     |
721  |     pub(crate) async fn is_self_addr(&self, addr: &str) -> Result<bool> {
     |                         ^^^^^^^^^^^^        ----------
help: consider using `Option::expect` to unwrap the `std::option::Option<&str>` value, panicking if the value is an `Option::None`
     |
3727 |     if context.is_self_addr(contact.get_addr().expect("REASON")).await? {
     |                                               +++++++++++++++++

error[E0599]: no method named `to_lowercase` found for enum `std::option::Option` in the current scope
    --> src/chat.rs:3758:47
     |
3758 |         let contact_addr = contact.get_addr().to_lowercase();
     |                                               ^^^^^^^^^^^^ method not found in `Option<&str>`
     |
note: the method `to_lowercase` exists on the type `&str`
    --> /home/k/.rustup/toolchains/1.77.1-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/str.rs:368:5
     |
368  |     pub fn to_lowercase(&self) -> String {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Option::expect` to unwrap the `&str` value, panicking if the value is an `Option::None`
     |
3758 |         let contact_addr = contact.get_addr().expect("REASON").to_lowercase();
     |                                              +++++++++++++++++

error[E0308]: mismatched types
    --> src/chat.rs:3925:29
     |
3923 |                         msg.text = stock_str::msg_del_member_local(
     |                                    ------------------------------- arguments to this function are incorrect
3924 |                             context,
3925 |                             contact.get_addr(),
     |                             ^^^^^^^^^^^^^^^^^^ expected `&str`, found `Option<&str>`
     |
     = note: expected reference `&str`
                     found enum `std::option::Option<&str>`
note: function defined here
    --> src/stock_str.rs:709:21
     |
709  | pub(crate) async fn msg_del_member_local(
     |                     ^^^^^^^^^^^^^^^^^^^^
710  |     context: &Context,
711  |     removed_member_addr: &str,
     |     -------------------------
help: consider using `Option::expect` to unwrap the `std::option::Option<&str>` value, panicking if the value is an `Option::None`
     |
3925 |                             contact.get_addr().expect("REASON"),
     |                                               +++++++++++++++++

error[E0599]: no method named `to_lowercase` found for enum `std::option::Option` in the current scope
    --> src/chat.rs:3931:66
     |
3931 |                     msg.param.set(Param::Arg, contact.get_addr().to_lowercase());
     |                                                                  ^^^^^^^^^^^^ method not found in `Option<&str>`
     |
note: the method `to_lowercase` exists on the type `&str`
    --> /home/k/.rustup/toolchains/1.77.1-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/str.rs:368:5
     |
368  |     pub fn to_lowercase(&self) -> String {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Option::expect` to unwrap the `&str` value, panicking if the value is an `Option::None`
     |
3931 |                     msg.param.set(Param::Arg, contact.get_addr().expect("REASON").to_lowercase());
     |                                                                 +++++++++++++++++

error[E0308]: mismatched types
   --> src/receive_imf.rs:363:47
    |
363 |                 Peerstate::from_addr(context, contact.get_addr()).await?;
    |                 --------------------          ^^^^^^^^^^^^^^^^^^ expected `&str`, found `Option<&str>`
    |                 |
    |                 arguments to this function are incorrect
    |
    = note: expected reference `&str`
                    found enum `std::option::Option<&str>`
note: associated function defined here
   --> src/peerstate.rs:170:18
    |
170 |     pub async fn from_addr(context: &Context, addr: &str) -> Result<Option<Peerstate>> {
    |                  ^^^^^^^^^                    ----------
help: consider using `Option::expect` to unwrap the `std::option::Option<&str>` value, panicking if the value is an `Option::None`
    |
363 |                 Peerstate::from_addr(context, contact.get_addr().expect("REASON")).await?;
    |                                                                 +++++++++++++++++

error[E0599]: the method `to_string` exists for enum `Option<&str>`, but its trait bounds were not satisfied
    --> src/smtp.rs:759:56
     |
759  |     let recipient = async_smtp::EmailAddress::new(addr.to_string())
     |                                                        ^^^^^^^^^ method cannot be called on `Option<&str>` due to unsatisfied trait bounds
     |
    ::: /home/k/.rustup/toolchains/1.77.1-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:570:1
     |
570  | pub enum Option<T> {
     | ------------------ doesn't satisfy `std::option::Option<&str>: ToString` or `std::option::Option<&str>: std::fmt::Display`
     |
     = note: the following trait bounds were not satisfied:
             `std::option::Option<&str>: std::fmt::Display`
             which is required by `std::option::Option<&str>: ToString`
note: the method `to_string` exists on the type `&str`
    --> /home/k/.rustup/toolchains/1.77.1-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/string.rs:2589:5
     |
2589 |     fn to_string(&self) -> String;
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Option::expect` to unwrap the `&str` value, panicking if the value is an `Option::None`
     |
759  |     let recipient = async_smtp::EmailAddress::new(addr.expect("REASON").to_string())
     |                                                       +++++++++++++++++

error[E0277]: `std::option::Option<&str>` doesn't implement `std::fmt::Display`
   --> src/smtp.rs:760:66
    |
760 |         .map_err(|err| format_err!("invalid recipient: {} {:?}", addr, err))?;
    |                                                                  ^^^^ `std::option::Option<&str>` cannot be formatted with the default formatter
    |
    = help: the trait `std::fmt::Display` is not implemented for `std::option::Option<&str>`
    = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
    = note: this error originates in the macro `$crate::__export::format_args` which comes from the expansion of the macro `format_err` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
    --> src/contact.rs:1477:65
     |
1477 |         let Some(verifier_addr) = Peerstate::from_addr(context, self.get_addr())
     |                                   --------------------          ^^^^^^^^^^^^^^^ expected `&str`, found `Option<&str>`
     |                                   |
     |                                   arguments to this function are incorrect
     |
     = note: expected reference `&str`
                     found enum `std::option::Option<&str>`
note: associated function defined here
    --> src/peerstate.rs:170:18
     |
170  |     pub async fn from_addr(context: &Context, addr: &str) -> Result<Option<Peerstate>> {
     |                  ^^^^^^^^^                    ----------
help: consider using `Option::expect` to unwrap the `std::option::Option<&str>` value, panicking if the value is an `Option::None`
     |
1477 |         let Some(verifier_addr) = Peerstate::from_addr(context, self.get_addr().expect("REASON"))
     |                                                                                +++++++++++++++++

error[E0277]: `std::option::Option<&str>` doesn't implement `std::fmt::Display`
   --> src/message.rs:223:59
    |
223 |             ret += &format!(" by ~{override_sender_name} ({addr})");
    |                                                           ^^^^^^ `std::option::Option<&str>` cannot be formatted with the default formatter
    |
    = help: the trait `std::fmt::Display` is not implemented for `std::option::Option<&str>`
    = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
    = note: this error originates in the macro `$crate::__export::format_args` which comes from the expansion of the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: the method `to_string` exists for enum `Option<&str>`, but its trait bounds were not satisfied
    --> src/mimefactory.rs:272:36
     |
272  |                 contact.get_addr().to_string(),
     |                                    ^^^^^^^^^ method cannot be called on `Option<&str>` due to unsatisfied trait bounds
     |
    ::: /home/k/.rustup/toolchains/1.77.1-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:570:1
     |
570  | pub enum Option<T> {
     | ------------------ doesn't satisfy `std::option::Option<&str>: ToString` or `std::option::Option<&str>: std::fmt::Display`
     |
     = note: the following trait bounds were not satisfied:
             `std::option::Option<&str>: std::fmt::Display`
             which is required by `std::option::Option<&str>: ToString`
note: the method `to_string` exists on the type `&str`
    --> /home/k/.rustup/toolchains/1.77.1-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/string.rs:2589:5
     |
2589 |     fn to_string(&self) -> String;
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Option::expect` to unwrap the `&str` value, panicking if the value is an `Option::None`
     |
272  |                 contact.get_addr().expect("REASON").to_string(),
     |                                   +++++++++++++++++

error[E0277]: `std::option::Option<&str>` doesn't implement `std::fmt::Display`
    --> src/context.rs:1443:13
     |
1443 |             contact.get_addr(),
     |             ^^^^^^^^^^^^^^^^^^ `std::option::Option<&str>` cannot be formatted with the default formatter
     |
     = help: the trait `std::fmt::Display` is not implemented for `std::option::Option<&str>`
     = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
     = note: this error originates in the macro `$crate::__export::format_args` which comes from the expansion of the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: the method `to_string` exists for enum `Option<&str>`, but its trait bounds were not satisfied
    --> src/qr_code_generator.rs:90:36
     |
90   |         None => contact.get_addr().to_string(),
     |                                    ^^^^^^^^^ method cannot be called on `Option<&str>` due to unsatisfied trait bounds
     |
    ::: /home/k/.rustup/toolchains/1.77.1-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:570:1
     |
570  | pub enum Option<T> {
     | ------------------ doesn't satisfy `std::option::Option<&str>: ToString` or `std::option::Option<&str>: std::fmt::Display`
     |
     = note: the following trait bounds were not satisfied:
             `std::option::Option<&str>: std::fmt::Display`
             which is required by `std::option::Option<&str>: ToString`
note: the method `to_string` exists on the type `&str`
    --> /home/k/.rustup/toolchains/1.77.1-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/string.rs:2589:5
     |
2589 |     fn to_string(&self) -> String;
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Option::expect` to unwrap the `&str` value, panicking if the value is an `Option::None`
     |
90   |         None => contact.get_addr().expect("REASON").to_string(),
     |                                   +++++++++++++++++

error[E0599]: the method `to_string` exists for enum `Option<&str>`, but its trait bounds were not satisfied
    --> src/qr_code_generator.rs:92:35
     |
92   |     let addr = contact.get_addr().to_string();
     |                                   ^^^^^^^^^ method cannot be called on `Option<&str>` due to unsatisfied trait bounds
     |
    ::: /home/k/.rustup/toolchains/1.77.1-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:570:1
     |
570  | pub enum Option<T> {
     | ------------------ doesn't satisfy `std::option::Option<&str>: ToString` or `std::option::Option<&str>: std::fmt::Display`
     |
     = note: the following trait bounds were not satisfied:
             `std::option::Option<&str>: std::fmt::Display`
             which is required by `std::option::Option<&str>: ToString`
note: the method `to_string` exists on the type `&str`
    --> /home/k/.rustup/toolchains/1.77.1-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/string.rs:2589:5
     |
2589 |     fn to_string(&self) -> String;
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Option::expect` to unwrap the `&str` value, panicking if the value is an `Option::None`
     |
92   |     let addr = contact.get_addr().expect("REASON").to_string();
     |                                  +++++++++++++++++

error[E0277]: can't compare `std::string::String` with `std::option::Option<&str>`
    --> src/stock_str.rs:1389:28
     |
1389 |         Some(name) if name != addr => format!("{name} ({addr})"),
     |                            ^^ no implementation for `std::string::String == std::option::Option<&str>`
     |
     = help: the trait `PartialEq<std::option::Option<&str>>` is not implemented for `std::string::String`
     = help: the following other types implement trait `PartialEq<Rhs>`:
               <std::string::String as PartialEq<tokio_util::bytes::Bytes>>
               <std::string::String as PartialEq<BytesMut>>
               <std::string::String as PartialEq<Cow<'a, str>>>
               <std::string::String as PartialEq<bstr::bstr::BStr>>
               <std::string::String as PartialEq<bstr::bstring::BString>>
               <std::string::String as PartialEq<stun_rs::attributes::stun::nonce::Nonce>>
               <std::string::String as PartialEq<stun_rs::attributes::stun::realm::Realm>>
               <std::string::String as PartialEq<stun_rs::attributes::stun::software::Software>>
             and 12 others

error[E0277]: `std::option::Option<&str>` doesn't implement `std::fmt::Display`
    --> src/stock_str.rs:1389:56
     |
1389 |         Some(name) if name != addr => format!("{name} ({addr})"),
     |                                                        ^^^^^^ `std::option::Option<&str>` cannot be formatted with the default formatter
     |
     = help: the trait `std::fmt::Display` is not implemented for `std::option::Option<&str>`
     = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
     = note: this error originates in the macro `$crate::__export::format_args` which comes from the expansion of the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: the method `to_string` exists for enum `Option<&str>`, but its trait bounds were not satisfied
    --> src/stock_str.rs:1390:19
     |
1390 |         _ => addr.to_string(),
     |                   ^^^^^^^^^ method cannot be called on `Option<&str>` due to unsatisfied trait bounds
     |
    ::: /home/k/.rustup/toolchains/1.77.1-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:570:1
     |
570  | pub enum Option<T> {
     | ------------------ doesn't satisfy `std::option::Option<&str>: ToString` or `std::option::Option<&str>: std::fmt::Display`
     |
     = note: the following trait bounds were not satisfied:
             `std::option::Option<&str>: std::fmt::Display`
             which is required by `std::option::Option<&str>: ToString`
note: the method `to_string` exists on the type `&str`
    --> /home/k/.rustup/toolchains/1.77.1-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/string.rs:2589:5
     |
2589 |     fn to_string(&self) -> String;
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Option::expect` to unwrap the `&str` value, panicking if the value is an `Option::None`
     |
1390 |         _ => addr.expect("REASON").to_string(),
     |                  +++++++++++++++++

error[E0308]: mismatched types
   --> src/securejoin.rs:210:57
    |
210 |     let peerstate = match Peerstate::from_addr(context, contact.get_addr()).await {
    |                           --------------------          ^^^^^^^^^^^^^^^^^^ expected `&str`, found `Option<&str>`
    |                           |
    |                           arguments to this function are incorrect
    |
    = note: expected reference `&str`
                    found enum `std::option::Option<&str>`
note: associated function defined here
   --> src/peerstate.rs:170:18
    |
170 |     pub async fn from_addr(context: &Context, addr: &str) -> Result<Option<Peerstate>> {
    |                  ^^^^^^^^^                    ----------
help: consider using `Option::expect` to unwrap the `std::option::Option<&str>` value, panicking if the value is an `Option::None`
    |
210 |     let peerstate = match Peerstate::from_addr(context, contact.get_addr().expect("REASON")).await {
    |                                                                           +++++++++++++++++

error[E0277]: `std::option::Option<&str>` doesn't implement `std::fmt::Display`
   --> src/securejoin.rs:216:17
    |
216 |                 contact.get_addr(),
    |                 ^^^^^^^^^^^^^^^^^^ `std::option::Option<&str>` cannot be formatted with the default formatter
    |
    = help: the trait `std::fmt::Display` is not implemented for `std::option::Option<&str>`
    = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
    = note: this error originates in the macro `$crate::__export::format_args` which comes from the expansion of the macro `warn` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
   --> src/securejoin.rs:232:81
    |
232 |                 peerstate.set_verified(public_key.clone(), fingerprint.clone(), verifier)?;
    |                           ------------ arguments to this method are incorrect   ^^^^^^^^ expected `String`, found `Option<&str>`
    |
    = note: expected struct `std::string::String`
                 found enum `std::option::Option<&str>`
note: method defined here
   --> src/peerstate.rs:496:12
    |
496 |     pub fn set_verified(
    |            ^^^^^^^^^^^^
...
500 |         verifier: String,
    |         ----------------

error[E0308]: mismatched types
   --> src/securejoin.rs:435:17
    |
432 |             let fingerprint_found = mark_peer_as_verified(
    |                                     --------------------- arguments to this function are incorrect
...
435 |                 contact_addr,
    |                 ^^^^^^^^^^^^ expected `String`, found `Option<&str>`
    |
    = note: expected struct `std::string::String`
                 found enum `std::option::Option<&str>`
note: function defined here
   --> src/securejoin.rs:705:10
    |
705 | async fn mark_peer_as_verified(
    |          ^^^^^^^^^^^^^^^^^^^^^
...
708 |     verifier: String,
    |     ----------------

error[E0599]: no method named `to_lowercase` found for enum `std::option::Option` in the current scope
   --> src/securejoin.rs:596:10
    |
593 |       let addr = Contact::get_by_id(context, contact_id)
    |  ________________-
594 | |         .await?
595 | |         .get_addr()
596 | |         .to_lowercase();
    | |         -^^^^^^^^^^^^ method not found in `Option<&str>`
    | |_________|
    | 
    |
note: the method `to_lowercase` exists on the type `&str`
   --> /home/k/.rustup/toolchains/1.77.1-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/str.rs:368:5
    |
368 |     pub fn to_lowercase(&self) -> String {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Option::expect` to unwrap the `&str` value, panicking if the value is an `Option::None`
    |
595 |         .get_addr().expect("REASON")
    |                    +++++++++++++++++

error[E0308]: mismatched types
    --> src/receive_imf.rs:2187:25
     |
2185 |                     stock_str::msg_add_member_local(
     |                     ------------------------------- arguments to this function are incorrect
2186 |                         context,
2187 |                         contact.get_addr(),
     |                         ^^^^^^^^^^^^^^^^^^ expected `&str`, found `Option<&str>`
     |
     = note: expected reference `&str`
                     found enum `std::option::Option<&str>`
note: function defined here
    --> src/stock_str.rs:658:21
     |
658  | pub(crate) async fn msg_add_member_local(
     |                     ^^^^^^^^^^^^^^^^^^^^
659  |     context: &Context,
660  |     added_member_addr: &str,
     |     -----------------------
help: consider using `Option::expect` to unwrap the `std::option::Option<&str>` value, panicking if the value is an `Option::None`
     |
2187 |                         contact.get_addr().expect("REASON"),
     |                                           +++++++++++++++++

error[E0277]: can't compare `std::string::String` with `std::option::Option<&str>`
    --> src/stock_str.rs:1389:28
     |
1389 |         Some(name) if name != addr => format!("{name} ({addr})"),
     |                            ^^ no implementation for `std::string::String == std::option::Option<&str>`
     |
     = help: the trait `PartialEq<std::option::Option<&str>>` is not implemented for `std::string::String`
     = help: the following other types implement trait `PartialEq<Rhs>`:
               <std::string::String as PartialEq<Utf8Path>>
               <std::string::String as PartialEq<tokio_util::bytes::Bytes>>
               <std::string::String as PartialEq<Utf8PathBuf>>
               <std::string::String as PartialEq<BytesMut>>
               <std::string::String as PartialEq<Cow<'a, str>>>
               <std::string::String as PartialEq<bstr::bstr::BStr>>
               <std::string::String as PartialEq<bstr::bstring::BString>>
               <std::string::String as PartialEq<stun_rs::attributes::stun::nonce::Nonce>>
             and 18 others

error[E0599]: no method named `to_lowercase` found for enum `std::option::Option` in the current scope
    --> src/receive_imf.rs:1719:35
     |
1719 |             if contact.get_addr().to_lowercase() == addr.to_lowercase() {
     |                                   ^^^^^^^^^^^^ method not found in `Option<&str>`
     |
note: the method `to_lowercase` exists on the type `&str`
    --> /home/k/.rustup/toolchains/1.77.1-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/str.rs:368:5
     |
368  |     pub fn to_lowercase(&self) -> String {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Option::expect` to unwrap the `&str` value, panicking if the value is an `Option::None`
     |
1719 |             if contact.get_addr().expect("REASON").to_lowercase() == addr.to_lowercase() {
     |                                  +++++++++++++++++

error[E0277]: `std::option::Option<&str>` doesn't implement `std::fmt::Display`
    --> src/receive_imf.rs:2700:37
     |
2700 |                     info!(context, "{verifier_addr} has verified {to_addr}.");
     |                                     ^^^^^^^^^^^^^^^ `std::option::Option<&str>` cannot be formatted with the default formatter
     |
     = help: the trait `std::fmt::Display` is not implemented for `std::option::Option<&str>`
     = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
     = note: this error originates in the macro `$crate::__export::format_args` which comes from the expansion of the macro `info` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
    --> src/receive_imf.rs:2702:74
     |
2702 |                         peerstate.set_verified(gossiped_key.clone(), fp, verifier_addr)?;
     |                                   ------------                           ^^^^^^^^^^^^^ expected `String`, found `Option<&str>`
     |                                   |
     |                                   arguments to this method are incorrect
     |
     = note: expected struct `std::string::String`
                  found enum `std::option::Option<&str>`
note: method defined here
    --> src/peerstate.rs:496:12
     |
496  |     pub fn set_verified(
     |            ^^^^^^^^^^^^
...
500  |         verifier: String,
     |         ----------------

error[E0308]: mismatched types
    --> src/receive_imf.rs:2724:80
     |
2724 |                     peerstate.set_secondary_verified_key(gossiped_key.clone(), verifier_addr);
     |                               --------------------------                       ^^^^^^^^^^^^^ expected `String`, found `Option<&str>`
     |                               |
     |                               arguments to this method are incorrect
     |
     = note: expected struct `std::string::String`
                  found enum `std::option::Option<&str>`
note: method defined here
    --> src/peerstate.rs:519:12
     |
519  |     pub fn set_secondary_verified_key(&mut self, gossip_key: SignedPublicKey, verifier: String) {
     |            ^^^^^^^^^^^^^^^^^^^^^^^^^^                                         ----------------

error[E0599]: no method named `is_none` found for reference `&Contact` in the current scope
    --> src/contact.rs:1313:13
     |
1313 |     if self.is_none() || self.magic!= DC_CONTACT_MAGIC {
     |             ^^^^^^^ method not found in `&Contact`

error[E0609]: no field `magic` on type `&Contact`
    --> src/contact.rs:1313:31
     |
1313 |     if self.is_none() || self.magic!= DC_CONTACT_MAGIC {
     |                               ^^^^^ unknown field
     |
     = note: available fields are: `id`, `name`, `authname`, `addr`, `blocked` ... and 5 others

Some errors have detailed explanations: E0277, E0308, E0425, E0599, E0609.
For more information about an error, try `rustc --explain E0277`.
error: could not compile `deltachat` (lib) due to 34 previous errors
warning: build failed, waiting for other jobs to finish...
error[E0599]: the method `to_string` exists for enum `Option<&str>`, but its trait bounds were not satisfied
    --> src/test_utils.rs:711:32
     |
711  |             contact.get_addr().to_string()
     |                                ^^^^^^^^^ method cannot be called on `Option<&str>` due to unsatisfied trait bounds
     |
    ::: /home/k/.rustup/toolchains/1.77.1-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:570:1
     |
570  | pub enum Option<T> {
     | ------------------ doesn't satisfy `std::option::Option<&str>: ToString` or `std::option::Option<&str>: std::fmt::Display`
     |
     = note: the following trait bounds were not satisfied:
             `std::option::Option<&str>: std::fmt::Display`
             which is required by `std::option::Option<&str>: ToString`
note: the method `to_string` exists on the type `&str`
    --> /home/k/.rustup/toolchains/1.77.1-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/string.rs:2589:5
     |
2589 |     fn to_string(&self) -> String;
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Option::expect` to unwrap the `&str` value, panicking if the value is an `Option::None`
     |
711  |             contact.get_addr().expect("REASON").to_string()
     |                               +++++++++++++++++

error[E0308]: mismatched types
   --> src/events/chatlist_events.rs:251:41
    |
251 |         Contact::create(&bob, "Alice2", addr).await?;
    |         ---------------                 ^^^^ expected `&str`, found `Option<&str>`
    |         |
    |         arguments to this function are incorrect
    |
    = note: expected reference `&str`
                    found enum `std::option::Option<&str>`
note: associated function defined here
   --> src/contact.rs:619:18
    |
619 |     pub async fn create(context: &Context, name: &str, addr: &str) -> Result<ContactId> {
    |                  ^^^^^^                                ----------
help: consider using `Option::expect` to unwrap the `std::option::Option<&str>` value, panicking if the value is an `Option::None`
    |
251 |         Contact::create(&bob, "Alice2", addr.expect("REASON")).await?;
    |                                             +++++++++++++++++

error[E0308]: mismatched types
    --> src/chat.rs:6784:41
     |
6784 |         assert_eq!(msg_from.get_addr(), "alice@example.org");
     |                                         ^^^^^^^^^^^^^^^^^^^ expected `Option<&str>`, found `&str`
     |
     = note:   expected enum `std::option::Option<&str>`
             found reference `&str`
help: try wrapping the expression in `Some`
     |
6784 |         assert_eq!(msg_from.get_addr(), Some("alice@example.org"));
     |                                         +++++                   +

error[E0599]: no method named `is_none` found for reference `&contact::Contact` in the current scope
    --> src/contact.rs:1313:13
     |
1313 |     if self.is_none() || self.magic!= DC_CONTACT_MAGIC {
     |             ^^^^^^^ method not found in `&Contact`

error[E0609]: no field `magic` on type `&contact::Contact`
    --> src/contact.rs:1313:31
     |
1313 |     if self.is_none() || self.magic!= DC_CONTACT_MAGIC {
     |                               ^^^^^ unknown field
     |
     = note: available fields are: `id`, `name`, `authname`, `addr`, `blocked` ... and 5 others

error[E0308]: mismatched types
    --> src/contact.rs:2106:40
     |
2106 |         assert_eq!(contact.get_addr(), "one@eins.org");
     |                                        ^^^^^^^^^^^^^^ expected `Option<&str>`, found `&str`
     |
     = note:   expected enum `std::option::Option<&str>`
             found reference `&str`
help: try wrapping the expression in `Some`
     |
2106 |         assert_eq!(contact.get_addr(), Some("one@eins.org"));
     |                                        +++++              +

error[E0308]: mismatched types
    --> src/contact.rs:2122:40
     |
2122 |         assert_eq!(contact.get_addr(), "one@eins.org");
     |                                        ^^^^^^^^^^^^^^ expected `Option<&str>`, found `&str`
     |
     = note:   expected enum `std::option::Option<&str>`
             found reference `&str`
help: try wrapping the expression in `Some`
     |
2122 |         assert_eq!(contact.get_addr(), Some("one@eins.org"));
     |                                        +++++              +

error[E0308]: mismatched types
    --> src/contact.rs:2139:40
     |
2139 |         assert_eq!(contact.get_addr(), "three@drei.sam");
     |                                        ^^^^^^^^^^^^^^^^ expected `Option<&str>`, found `&str`
     |
     = note:   expected enum `std::option::Option<&str>`
             found reference `&str`
help: try wrapping the expression in `Some`
     |
2139 |         assert_eq!(contact.get_addr(), Some("three@drei.sam"));
     |                                        +++++                +

error[E0308]: mismatched types
    --> src/contact.rs:2187:40
     |
2187 |         assert_eq!(contact.get_addr(), "alice@w.de");
     |                                        ^^^^^^^^^^^^ expected `Option<&str>`, found `&str`
     |
     = note:   expected enum `std::option::Option<&str>`
             found reference `&str`
help: try wrapping the expression in `Some`
     |
2187 |         assert_eq!(contact.get_addr(), Some("alice@w.de"));
     |                                        +++++            +

error[E0308]: mismatched types
    --> src/contact.rs:2193:40
     |
2193 |         assert_eq!(contact.get_addr(), ""); // we're not configured
     |                                        ^^ expected `Option<&str>`, found `&str`
     |
     = note:   expected enum `std::option::Option<&str>`
             found reference `&str`
help: try wrapping the expression in `Some`
     |
2193 |         assert_eq!(contact.get_addr(), Some("")); // we're not configured
     |                                        +++++  +

error[E0308]: mismatched types
    --> src/contact.rs:2596:40
     |
2596 |         assert_eq!(contact.get_addr(), "dave@example.org");
     |                                        ^^^^^^^^^^^^^^^^^^ expected `Option<&str>`, found `&str`
     |
     = note:   expected enum `std::option::Option<&str>`
             found reference `&str`
help: try wrapping the expression in `Some`
     |
2596 |         assert_eq!(contact.get_addr(), Some("dave@example.org"));
     |                                        +++++                  +

error[E0308]: mismatched types
    --> src/contact.rs:2603:40
     |
2603 |         assert_eq!(contact.get_addr(), "dave@example.org");
     |                                        ^^^^^^^^^^^^^^^^^^ expected `Option<&str>`, found `&str`
     |
     = note:   expected enum `std::option::Option<&str>`
             found reference `&str`
help: try wrapping the expression in `Some`
     |
2603 |         assert_eq!(contact.get_addr(), Some("dave@example.org"));
     |                                        +++++                  +

error[E0308]: mismatched types
    --> src/contact.rs:2610:40
     |
2610 |         assert_eq!(contact.get_addr(), "dave@example.org");
     |                                        ^^^^^^^^^^^^^^^^^^ expected `Option<&str>`, found `&str`
     |
     = note:   expected enum `std::option::Option<&str>`
             found reference `&str`
help: try wrapping the expression in `Some`
     |
2610 |         assert_eq!(contact.get_addr(), Some("dave@example.org"));
     |                                        +++++                  +

error[E0308]: mismatched types
   --> src/qr.rs:887:44
    |
887 |             assert_eq!(contact.get_addr(), "stress@test.local");
    |                                            ^^^^^^^^^^^^^^^^^^^ expected `Option<&str>`, found `&str`
    |
    = note:   expected enum `std::option::Option<&str>`
            found reference `&str`
help: try wrapping the expression in `Some`
    |
887 |             assert_eq!(contact.get_addr(), Some("stress@test.local"));
    |                                            +++++                   +

error[E0308]: mismatched types
   --> src/qr.rs:911:44
    |
911 |             assert_eq!(contact.get_addr(), "stress@test.local");
    |                                            ^^^^^^^^^^^^^^^^^^^ expected `Option<&str>`, found `&str`
    |
    = note:   expected enum `std::option::Option<&str>`
            found reference `&str`
help: try wrapping the expression in `Some`
    |
911 |             assert_eq!(contact.get_addr(), Some("stress@test.local"));
    |                                            +++++                   +

error[E0308]: mismatched types
   --> src/qr.rs:931:44
    |
931 |             assert_eq!(contact.get_addr(), "stress@test.local");
    |                                            ^^^^^^^^^^^^^^^^^^^ expected `Option<&str>`, found `&str`
    |
    = note:   expected enum `std::option::Option<&str>`
            found reference `&str`
help: try wrapping the expression in `Some`
    |
931 |             assert_eq!(contact.get_addr(), Some("stress@test.local"));
    |                                            +++++                   +

error[E0308]: mismatched types
   --> src/qr.rs:940:44
    |
940 |             assert_eq!(contact.get_addr(), "no-questionmark@example.org");
    |                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Option<&str>`, found `&str`
    |
    = note:   expected enum `std::option::Option<&str>`
            found reference `&str`
help: try wrapping the expression in `Some`
    |
940 |             assert_eq!(contact.get_addr(), Some("no-questionmark@example.org"));
    |                                            +++++                             +

error[E0308]: mismatched types
   --> src/qr.rs:960:44
    |
960 |             assert_eq!(contact.get_addr(), "stress@test.local");
    |                                            ^^^^^^^^^^^^^^^^^^^ expected `Option<&str>`, found `&str`
    |
    = note:   expected enum `std::option::Option<&str>`
            found reference `&str`
help: try wrapping the expression in `Some`
    |
960 |             assert_eq!(contact.get_addr(), Some("stress@test.local"));
    |                                            +++++                   +

error[E0308]: mismatched types
    --> src/qr.rs:1038:44
     |
1038 |             assert_eq!(contact.get_addr(), "cli@deltachat.de");
     |                                            ^^^^^^^^^^^^^^^^^^ expected `Option<&str>`, found `&str`
     |
     = note:   expected enum `std::option::Option<&str>`
             found reference `&str`
help: try wrapping the expression in `Some`
     |
1038 |             assert_eq!(contact.get_addr(), Some("cli@deltachat.de"));
     |                                            +++++                  +

error[E0308]: mismatched types
    --> src/qr.rs:1084:44
     |
1084 |             assert_eq!(contact.get_addr(), "cli@deltachat.de");
     |                                            ^^^^^^^^^^^^^^^^^^ expected `Option<&str>`, found `&str`
     |
     = note:   expected enum `std::option::Option<&str>`
             found reference `&str`
help: try wrapping the expression in `Some`
     |
1084 |             assert_eq!(contact.get_addr(), Some("cli@deltachat.de"));
     |                                            +++++                  +

error[E0308]: mismatched types
    --> src/qr.rs:1099:44
     |
1099 |             assert_eq!(contact.get_addr(), "cli@deltachat.de");
     |                                            ^^^^^^^^^^^^^^^^^^ expected `Option<&str>`, found `&str`
     |
     = note:   expected enum `std::option::Option<&str>`
             found reference `&str`
help: try wrapping the expression in `Some`
     |
1099 |             assert_eq!(contact.get_addr(), Some("cli@deltachat.de"));
     |                                            +++++                  +

error[E0308]: mismatched types
   --> src/receive_imf/tests.rs:900:37
    |
900 |     assert_eq!(contact1.get_addr(), "notifications@github.com");
    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Option<&str>`, found `&str`
    |
    = note:   expected enum `std::option::Option<&str>`
            found reference `&str`
help: try wrapping the expression in `Some`
    |
900 |     assert_eq!(contact1.get_addr(), Some("notifications@github.com"));
    |                                     +++++                          +

error[E0308]: mismatched types
   --> src/receive_imf/tests.rs:905:37
    |
905 |     assert_eq!(contact2.get_addr(), "notifications@github.com");
    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Option<&str>`, found `&str`
    |
    = note:   expected enum `std::option::Option<&str>`
            found reference `&str`
help: try wrapping the expression in `Some`
    |
905 |     assert_eq!(contact2.get_addr(), Some("notifications@github.com"));
    |                                     +++++                          +

error[E0308]: mismatched types
   --> src/receive_imf/tests.rs:950:37
    |
950 |     assert_eq!(contact1.get_addr(), "bob@posteo.org");
    |                                     ^^^^^^^^^^^^^^^^ expected `Option<&str>`, found `&str`
    |
    = note:   expected enum `std::option::Option<&str>`
            found reference `&str`
help: try wrapping the expression in `Some`
    |
950 |     assert_eq!(contact1.get_addr(), Some("bob@posteo.org"));
    |                                     +++++                +

error: could not compile `deltachat` (lib test) due to 57 previous errors
error: command `/home/k/.rustup/toolchains/1.77.1-x86_64-unknown-linux-gnu/bin/cargo test --no-run --message-format json-render-diagnostics` exited with code 101

