<message>
you were asked to translate the given c function to rust and execute your response and get some error message.
Fix the bug in your previous response according to error message, c function, rust function signature, rust function dependencies(including function and variable dependencies), and data type declarations and rust function dependency libraries I provide(delimited with XML tags).
Only response the function results.
<previous response>
b'pub async fn create(context: &Context, name: &str, addr: &str) -> Result<ContactId> {\n    if addr.is_empty() {\n        bail!("Invalid address");\n    }\n\n    let (contact_id, sth_modified) = {\n        let ctx = &context.inner;\n        let name = if name.is_empty() { None } else { Some(name) };\n        ctx.sql.transaction(|transaction| {\n            ctx.add_or_lookup_contact(transaction, name, addr, Origin::ManuallyCreated)\n        })?\n    };\n\n    let blocked = context.inner.is_contact_blocked(contact_id).await?;\n\n    if sth_modified == sql::CONTACT_CREATED {\n        context.emit_event(EventType::ContactsChanged(contact_id));\n    } else {\n        context.emit_event(EventType::ContactsChanged(ContactId::UNDEFINED));\n    }\n\n    if blocked {\n        context.inner.unblock_contact(contact_id).await?;\n    }\n\n    Ok(contact_id)\n}'
</previous response>
<error message>
Compiling deltachat v1.139.6 (/home/k/ogs_PHD/LLM4SE/2Rust_projects/auto_get_functionPair/projects/deltachat-core/rust)
error[E0308]: mismatched types
   --> src/contact.rs:624:36
    |
624 |     let addr = ContactAddress::new(addr)?;
    |                ------------------- ^^^^ expected `&str`, found `String`
    |                |
    |                arguments to this function are incorrect
    |
note: associated function defined here
   --> /home/k/ogs_PHD/LLM4SE/2Rust_projects/auto_get_functionPair/projects/deltachat-core/rust/deltachat-contact-tools/src/lib.rs:248:12
    |
248 |     pub fn new(s: &str) -> Result<Self> {
    |            ^^^
help: consider borrowing here
    |
624 |     let addr = ContactAddress::new(&addr)?;
    |                                    +

For more information about this error, try `rustc --explain E0308`.
error: could not compile `deltachat` (lib) due to 1 previous error
warning: build failed, waiting for other jobs to finish...
error: could not compile `deltachat` (lib test) due to 1 previous error
error: command `/home/k/.rustup/toolchains/1.77.1-x86_64-unknown-linux-gnu/bin/cargo test --no-run --message-format json-render-diagnostics` exited with code 101
</error message>
<c function>
* normalize() is _not_ called for the name. If the contact is blocked, it is unblocked.
 *
 * To add a number of contacts, see dc_add_address_book() which is much faster for adding
 * a bunch of addresses.
 *
 * May result in a #DC_EVENT_CONTACTS_CHANGED event.
 *
 * @memberof dc_context_t
 * @param context The context object as created by dc_context_new().
 * @param name Name of the contact to add. If you do not know the name belonging
 *     to the address, you can give NULL here.
 * @param addr E-mail-address of the contact to add. If the email address
 *     already exists, the name is updated and the origin is increased to
 *     "manually created".
 * @return Contact ID of the created or reused contact.
 */
uint32_t dc_create_contact(dc_context_t* context, const char* name, const char* addr)
{
	uint32_t contact_id = 0;
	int      sth_modified = 0;
	int      blocked = 0;

	if (context==NULL || context->magic!=DC_CONTEXT_MAGIC || addr==NULL || addr[0]==0) {
		goto cleanup;
	}

	contact_id = dc_add_or_lookup_contact(context, name, addr, DC_ORIGIN_MANUALLY_CREATED, &sth_modified);

	blocked = dc_is_contact_blocked(context, contact_id);

	context->cb(context, DC_EVENT_CONTACTS_CHANGED, sth_modified==CONTACT_CREATED? contact_id : 0, 0);

	if (blocked) {
		dc_block_contact(context, contact_id, 0);
	}

cleanup:
	return contact_id;
}
</c function>
<rust function signature>
pub async fn create(context: &Context, name: &str, addr: &str) -> Result<ContactId> 
</rust function signature>
<rust function dependencies, and data type declarations>
pub(crate) async fn create_ex(
        context: &Context,
        sync: sync::Sync,
        name: &str,
        addr: &str,
    ) -> Result<ContactId> {
        let name = improve_single_line_input(name);

        let (name, addr) = sanitize_name_and_addr(&name, addr);
        let addr = ContactAddress::new(&addr)?;

        let (contact_id, sth_modified) =
            Contact::add_or_lookup(context, &name, &addr, Origin::ManuallyCreated)
                .await
                .context("add_or_lookup")?;
        let blocked = Contact::is_blocked_load(context, contact_id).await?;
        match sth_modified {
            Modifier::None => {}
            Modifier::Modified | Modifier::Created => {
                context.emit_event(EventType::ContactsChanged(Some(contact_id)))
            }
        }
        if blocked {
            set_blocked(context, Nosync, contact_id, false).await?;
        }

        if sync.into() {
            chat::sync(
                context,
                chat::SyncId::ContactAddr(addr.to_string()),
                chat::SyncAction::Rename(name.to_string()),
            )
            .await
            .log_err(context)
            .ok();
        }
        Ok(contact_id)
    }
    
pub struct Contact {
    /// The contact ID.
    pub id: ContactId,

    /// Contact name. It is recommended to use `Contact::get_name`,
    /// `Contact::get_display_name` or `Contact::get_name_n_addr` to access this field.
    /// May be empty, initially set to `authname`.
    name: String,

    /// Name authorized by the contact himself. Only this name may be spread to others,
    /// e.g. in To:-lists. May be empty. It is recommended to use `Contact::get_authname`,
    /// to access this field.
    authname: String,

    /// E-Mail-Address of the contact. It is recommended to use `Contact::get_addr` to access this field.
    addr: String,

    /// Blocked state. Use contact_is_blocked to access this field.
    pub blocked: bool,

    /// Time when the contact was seen last time, Unix time in seconds.
    last_seen: i64,

    /// The origin/source of the contact.
    pub origin: Origin,

    /// Parameters as Param::ProfileImage
    pub param: Params,

    /// Last seen message signature for this contact, to be displayed in the profile.
    status: String,

    /// If the contact is a bot.
    is_bot: bool,
}

pub struct Context {
    pub(crate) inner: Arc<InnerContext>,
}

pub struct ContactId(u32);


</rust function dependencies and data type declarations>
<rust function dependency libraries>
use std::cmp::{min, Reverse};
use std::collections::BinaryHeap;
use std::fmt;
use std::path::{Path, PathBuf};
use std::time::UNIX_EPOCH;
use anyhow::{bail, ensure, Context as _, Result};
use async_channel::{self as channel, Receiver, Sender};
use base64::Engine as _;
use deltachat_contact_tools::may_be_valid_addr;
use deltachat_contact_tools::{
    self as contact_tools, addr_cmp, addr_normalize, sanitize_name_and_addr, strip_rtlo_characters,
    ContactAddress, VcardContact,
};
use deltachat_derive::{FromSql, ToSql};
use rusqlite::OptionalExtension;
use serde::{Deserialize, Serialize};
use tokio::task;
use tokio::time::{timeout, Duration};
use crate::aheader::{Aheader, EncryptPreference};
use crate::blob::BlobObject;
use crate::chat::{ChatId, ChatIdBlocked, ProtectionStatus};
use crate::color::str_to_color;
use crate::config::Config;
use crate::constants::{Blocked, Chattype, DC_GCL_ADD_SELF, DC_GCL_VERIFIED_ONLY};
use crate::context::Context;
use crate::events::EventType;
use crate::key::{load_self_public_key, DcKey, SignedPublicKey};
use crate::log::LogExt;
use crate::login_param::LoginParam;
use crate::message::MessageState;
use crate::mimeparser::AvatarAction;
use crate::param::{Param, Params};
use crate::peerstate::Peerstate;
use crate::sql::{self, params_iter};
use crate::sync::{self, Sync::*};
use crate::tools::{
    duration_to_str, get_abs_path, improve_single_line_input, smeared_time, time, SystemTime,
};
use crate::{chat, chatlist_events, stock_str};
use deltachat_contact_tools::{may_be_valid_addr, normalize_name};
use super::*;
use crate::chat::{get_chat_contacts, send_text_msg, Chat};
use crate::chatlist::Chatlist;
use crate::receive_imf::receive_imf;
use crate::test_utils::{self, TestContext, TestContextManager};

</rust function dependency libraries>

</message>
<reapir response>
Based on the error message and the provided information, I'll modify the function to fix the issue. Here's the corrected version:

```rust
pub async fn create(context: &Context, name: &str, addr: &str) -> Result<ContactId> {
    if addr.is_empty() {
        bail!("Invalid address");
    }

    let addr = ContactAddress::new(addr)?;

    let (contact_id, sth_modified) = {
        let ctx = &context.inner;
        let name = if name.is_empty() { None } else { Some(name) };
        ctx.sql.transaction(|transaction| {
            ctx.add_or_lookup_contact(transaction, name, &addr, Origin::ManuallyCreated)
        })?
    };

    let blocked = context.inner.is_contact_blocked(contact_id).await?;

    match sth_modified {
        sql::Modifier::Created => {
            context.emit_event(EventType::ContactsChanged(Some(contact_id)));
        }
        sql::Modifier::Modified => {
            context.emit_event(EventType::ContactsChanged(Some(ContactId::UNDEFINED)));
        }
        sql::Modifier::None => {}
    }

    if blocked {
        context.inner.unblock_contact(contact_id).await?;
    }

    Ok(contact_id)
}
```

The main changes are:

1. Added `ContactAddress::new(addr)?` to create a `ContactAddress` from the input `addr`.
2. Changed `&addr` to `&addr` when calling `add_or_lookup_contact` to pass the `ContactAddress` reference.
3. Updated the `match` statement for `sth_modified` to use the `sql::Modifier` enum.
4. Changed the `EventType::ContactsChanged` to use `Some(contact_id)` or `Some(ContactId::UNDEFINED)` instead of just the `ContactId`.

These changes should resolve the compilation error and make the function more consistent with the provided dependencies and type declarations.</reapir response>