<message>
please translate the given python function to rust according to the rust function signature, rust function realted variable, functions, and data type declarations and rust function dependency libraries I provide(delimited with XML tags). Only response the translated function results.
<python function>
def visit_not_nan(self, term: BoundTerm[L]) -> bool:
        field_id = term.ref().field.field_id

        if self._contains_nans_only(field_id):
            return ROWS_CANNOT_MATCH

        return ROWS_MIGHT_MATCH
</python function>
<rust function signature>
fn not_nan(
        &mut self,
        reference: &BoundReference,
        _predicate: &BoundPredicate,
    ) -> crate::Result<bool> 
</rust function signature>
<rust function realted variable, functions, and data type declarations>
pub(crate) struct InclusiveMetricsEvaluator<'a> {
    data_file: &'a DataFile,
}
pub struct BoundReference {
    // This maybe different from [`name`] filed in [`NestedField`] since this contains full path.
    // For example, if the field is `a.b.c`, then `field.name` is `c`, but `original_name` is `a.b.c`.
    column_name: String,
    field: NestedFieldRef,
    accessor: StructAccessorRef,
}
pub struct NestedField {
    /// Id unique in table schema
    pub id: i32,
    /// Field Name
    pub name: String,
    /// Optional or required
    pub required: bool,
    /// Datatype
    pub field_type: Box<Type>,
    /// Fields may have an optional comment or doc string.
    pub doc: Option<String>,
    /// Used to populate the field’s value for all records that were written before the field was added to the schema
    pub initial_default: Option<Literal>,
    /// Used to populate the field’s value for any records written after the field was added to the schema, if the writer does not supply the field’s value
    pub write_default: Option<Literal>,
}
const ROWS_CANNOT_MATCH: crate::Result<bool> = Ok(false);

</rust function realted variable, functions, and data type declarations>
<rust function dependency libraries>


use crate::expr::visitors::bound_predicate_visitor::{visit, BoundPredicateVisitor};
use crate::expr::{BoundPredicate, BoundReference};
use crate::spec::{DataFile, Datum, PrimitiveLiteral};
use crate::{Error, ErrorKind};
use fnv::FnvHashSet;
use crate::expr::visitors::inclusive_metrics_evaluator::InclusiveMetricsEvaluator;
use crate::expr::PredicateOperator::{
        Eq, GreaterThan, GreaterThanOrEq, In, IsNan, IsNull, LessThan, LessThanOrEq, NotEq, NotIn,
        NotNan, NotNull, NotStartsWith, StartsWith,
    };
use crate::expr::{
        BinaryExpression, Bind, BoundPredicate, Predicate, Reference, SetExpression,
        UnaryExpression,
    };
use crate::spec::{
        DataContentType, DataFile, DataFileFormat, Datum, NestedField, PartitionField,
        PartitionSpec, PrimitiveType, Schema, Struct, Transform, Type,
    };
use fnv::FnvHashSet;
use std::collections::HashMap;
use std::ops::Not;
use std::sync::Arc;

</rust function dependency libraries>

</message>
<function>
fn not_nan(
        &mut self,
        reference: &BoundReference,
        _predicate: &BoundPredicate,
    ) -> crate::Result<bool> {
        let field_id = reference.field().id;

        if self.contains_nans_only(field_id) {
            return ROWS_CANNOT_MATCH;
        }

        ROWS_MIGHT_MATCH
    }
</function>
<translated function>
In Rust, the signature of the function `visit_not_nan` doesn't match with the Python one because the field_id in Python is retrieved from the`BoundTerm[L]` while in Rust this field is accessed from `BoundReference`. However, I'll provide a translation assuming field_id can be accessed from `BoundReference` like:

`reference.field.id`

<rust function>
```rust
fn not_nan(
        &mut self,
        reference: &BoundReference,
        _predicate: &BoundPredicate,
    ) -> crate::Result<bool> {

        let field_id = reference.field.id;

        if self._contains_nans_only(field_id)? {
            return ROWS_CANNOT_MATCH
        }

        Ok(true)
    }
```
</rust function></translated function>In Rust, the signature of the function `visit_not_nan` doesn't match with the Python one because the field_id in Python is retrieved from the`BoundTerm[L]` while in Rust this field is accessed from `BoundReference`. However, I'll provide a translation assuming field_id can be accessed from `BoundReference` like:

`reference.field.id`

<rust function>
```rust
fn not_nan(
        &mut self,
        reference: &BoundReference,
        _predicate: &BoundPredicate,
    ) -> crate::Result<bool> {

        let field_id = reference.field.id;

        if self._contains_nans_only(field_id)? {
            return ROWS_CANNOT_MATCH
        }

        Ok(true)
    }
```
</rust function>