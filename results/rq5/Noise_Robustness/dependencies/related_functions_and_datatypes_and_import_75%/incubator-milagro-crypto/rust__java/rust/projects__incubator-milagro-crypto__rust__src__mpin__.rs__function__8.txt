fn emap(u: &Big, cb: isize) -> ECP {
    let mut P: ECP;
    let mut x = u.clone();
    let p = Big::new_ints(&rom::MODULUS);
    x.rmod(&p);
    loop {
        P = ECP::new_bigint(&x, cb);
        if !P.is_infinity() {
            break;
        }
        x.inc(1);
        x.norm();
    }
    return P;
}
pub fn gety(&self) -> FP2 {
        let mut W = self.clone();
        W.affine();
        W.y.clone()
    }
pub fn getx(&self) -> FP2 {
        let mut W = self.clone();
        W.affine();
        W.x.clone()
    }
pub fn to_bytes(&self, b: &mut [u8]) {
        let mut t: [u8; big::MODBYTES as usize] = [0; big::MODBYTES as usize];
        let mb = big::MODBYTES as usize;
        let mut W = self.clone();

        W.affine();
        W.x.geta().to_bytes(&mut t);
        for i in 0..mb {
            b[i] = t[i]
        }
        W.x.getb().to_bytes(&mut t);
        for i in 0..mb {
            b[i + mb] = t[i]
        }

        W.y.geta().to_bytes(&mut t);
        for i in 0..mb {
            b[i + 2 * mb] = t[i]
        }
        W.y.getb().to_bytes(&mut t);
        for i in 0..mb {
            b[i + 3 * mb] = t[i]
        }
    }
pub const EFS: usize = big::MODBYTES as usize;
pub fn from_bytes(b: &[u8]) -> Big {
        Big::from_byte_array(b, 0)
    }
------

use std::time::SystemTime;
use std::time::UNIX_EPOCH;
use super::big;
use super::big::Big;
use super::ecp;
use super::ecp::ECP;
use super::ecp2::ECP2;
use super::fp12::FP12;
use super::fp4::FP4;
use super::pair;
use super::rom;
use crate::hash256::HASH256;
use crate::hash384::HASH384;
use crate::hash512::HASH512;
use crate::rand::RAND;
use super::*;
use crate::test_utils::*;
