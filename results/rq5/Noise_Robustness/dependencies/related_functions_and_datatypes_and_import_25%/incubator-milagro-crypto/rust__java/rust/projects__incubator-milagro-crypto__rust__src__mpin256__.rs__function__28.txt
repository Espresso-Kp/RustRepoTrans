pub fn rmod(&mut self, n: &Big) {
        let mut k = 0;
        let mut m = n.clone();
        self.norm();
        if Big::comp(self, &m) < 0 {
            return;
        }
        loop {
            m.fshl(1);
            k += 1;
            if Big::comp(self, &m) < 0 {
                break;
            }
        }

        while k > 0 {
            m.fshr(1);

            let mut r = self.clone();
            r.sub(&m);
            r.norm();
            self.cmove(
                &r,
                (1 - ((r.w[NLEN - 1] >> (arch::CHUNK - 1)) & 1)) as isize,
            );
            k -= 1;
        }
    }
fn hash(sha: usize, c: &mut FP16, U: &mut ECP, r: &mut [u8]) -> bool {
    let mut w: [u8; EFS] = [0; EFS];
    let mut t: [u8; 18 * EFS] = [0; 18 * EFS];

    c.geta().geta().geta().geta().to_bytes(&mut w);
    for i in 0..EFS {
        t[i] = w[i]
    }
    c.geta().geta().geta().getb().to_bytes(&mut w);
    for i in EFS..2 * EFS {
        t[i] = w[i - EFS]
    }
    c.geta().geta().getb().geta().to_bytes(&mut w);
    for i in 2 * EFS..3 * EFS {
        t[i] = w[i - 2 * EFS]
    }
    c.geta().geta().getb().getb().to_bytes(&mut w);
    for i in 3 * EFS..4 * EFS {
        t[i] = w[i - 3 * EFS]
    }
    c.geta().getb().geta().geta().to_bytes(&mut w);
    for i in 4 * EFS..5 * EFS {
        t[i] = w[i - 4 * EFS]
    }
    c.geta().getb().geta().getb().to_bytes(&mut w);
    for i in 5 * EFS..6 * EFS {
        t[i] = w[i - 5 * EFS]
    }
    c.geta().getb().getb().geta().to_bytes(&mut w);
    for i in 6 * EFS..7 * EFS {
        t[i] = w[i - 6 * EFS]
    }
    c.geta().getb().getb().getb().to_bytes(&mut w);
    for i in 7 * EFS..8 * EFS {
        t[i] = w[i - 7 * EFS]
    }

    c.getb().geta().geta().geta().to_bytes(&mut w);
    for i in 8 * EFS..9 * EFS {
        t[i] = w[i - 8 * EFS]
    }
    c.getb().geta().geta().getb().to_bytes(&mut w);
    for i in 9 * EFS..10 * EFS {
        t[i] = w[i - 9 * EFS]
    }
    c.getb().geta().getb().geta().to_bytes(&mut w);
    for i in 10 * EFS..11 * EFS {
        t[i] = w[i - 10 * EFS]
    }
    c.getb().geta().getb().getb().to_bytes(&mut w);
    for i in 11 * EFS..12 * EFS {
        t[i] = w[i - 11 * EFS]
    }
    c.getb().getb().geta().geta().to_bytes(&mut w);
    for i in 12 * EFS..13 * EFS {
        t[i] = w[i - 12 * EFS]
    }
    c.getb().getb().geta().getb().to_bytes(&mut w);
    for i in 13 * EFS..14 * EFS {
        t[i] = w[i - 13 * EFS]
    }
    c.getb().getb().getb().geta().to_bytes(&mut w);
    for i in 14 * EFS..15 * EFS {
        t[i] = w[i - 14 * EFS]
    }
    c.getb().getb().getb().getb().to_bytes(&mut w);
    for i in 15 * EFS..16 * EFS {
        t[i] = w[i - 15 * EFS]
    }

    U.getx().to_bytes(&mut w);
    for i in 16 * EFS..17 * EFS {
        t[i] = w[i - 16 * EFS]
    }
    U.gety().to_bytes(&mut w);
    for i in 17 * EFS..18 * EFS {
        t[i] = w[i - 17 * EFS]
    }

    if sha == SHA256 {
        let mut h = HASH256::new();
        h.process_array(&t);
        let sh = h.hash();
        for i in 0..ecp::AESKEY {
            r[i] = sh[i]
        }
        return true;
    }
    if sha == SHA384 {
        let mut h = HASH384::new();
        h.process_array(&t);
        let sh = h.hash();
        for i in 0..ecp::AESKEY {
            r[i] = sh[i]
        }
        return true;
    }
    if sha == SHA512 {
        let mut h = HASH512::new();
        h.process_array(&t);
        let sh = h.hash();
        for i in 0..ecp::AESKEY {
            r[i] = sh[i]
        }
        return true;
    }
    return false;
}
pub fn from_bytes(b: &[u8]) -> Big {
        Big::from_byte_array(b, 0)
    }
pub fn g1mul(P: &ECP, e: &Big) -> ECP {
    if rom::USE_GLV {
        let mut R = P.clone();
        let mut Q = P.clone();
        Q.affine();
        let q = Big::new_ints(&rom::CURVE_ORDER);
        let mut cru = FP::new_big(Big::new_ints(&rom::CURVE_CRU));
        let mut u = glv(e);
        Q.mulx(&mut cru);

        let mut np = u[0].nbits();
        let mut t: Big = Big::modneg(&u[0], &q);
        let mut nn = t.nbits();
        if nn < np {
            u[0] = t.clone();
            R.neg();
        }

        np = u[1].nbits();
        t = Big::modneg(&u[1], &q);
        nn = t.nbits();
        if nn < np {
            u[1] = t;
            Q.neg();
        }
        u[0].norm();
        u[1].norm();
        R.mul2(&u[0], &Q, &u[1])
    } else {
        P.mul(e)
    }
}
------



use std::time::SystemTime;
use std::time::UNIX_EPOCH;
use super::big;
use super::big::Big;
use super::ecp;
use super::ecp::ECP;
use super::ecp8::ECP8;
use super::fp16::FP16;
use super::fp48::FP48;
use super::pair256;
use super::rom;
use crate::hash256::HASH256;
use crate::hash384::HASH384;
use crate::hash512::HASH512;
use crate::rand::RAND;
use super::*;
use crate::test_utils::*;
