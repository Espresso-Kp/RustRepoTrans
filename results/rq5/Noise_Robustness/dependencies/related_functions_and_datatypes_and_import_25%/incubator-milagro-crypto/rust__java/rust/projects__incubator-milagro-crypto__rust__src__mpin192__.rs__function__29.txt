pub fn trace(&mut self) -> FP8 {
        let mut t = self.geta();
        t.imul(3);
        t.reduce();
        return t;
    }
pub fn is_infinity(&self) -> bool {
        let xx = self.getpx();
        let zz = self.getpz();
        return xx.is_zilch() && zz.is_zilch();
    }
pub fn fexp(m: &FP24) -> FP24 {
    let f = FP2::new_bigs(Big::new_ints(&rom::FRA), Big::new_ints(&rom::FRB));
    let mut x = Big::new_ints(&rom::CURVE_BNX);
    let mut r = m.clone();

    /* Easy part of final exp */
    let mut lv = r.clone();
    lv.inverse();
    r.conj();

    r.mul(&lv);
    lv = r.clone();
    r.frob(&f, 4);
    r.mul(&lv);
    //    if r.is_unity() {
    //	r.zero();
    //	return r;
    //    }
    /* Hard part of final exp */
    // Ghamman & Fouotsa Method

    let mut t7 = r.clone();
    t7.usqr();
    let mut t1 = t7.pow(&mut x);

    x.fshr(1);
    let mut t2 = t1.pow(&mut x);
    x.fshl(1);

    if ecp::SIGN_OF_X == SignOfX::NegativeX {
        t1.conj();
    }
    let mut t3 = t1.clone();
    t3.conj();
    t2.mul(&t3);
    t2.mul(&r);

    t3 = t2.pow(&mut x);
    let mut t4 = t3.pow(&mut x);
    let mut t5 = t4.pow(&mut x);

    if ecp::SIGN_OF_X == SignOfX::NegativeX {
        t3.conj();
        t5.conj();
    }

    t3.frob(&f, 6);
    t4.frob(&f, 5);
    t3.mul(&t4);

    let mut t6 = t5.pow(&mut x);
    if ecp::SIGN_OF_X == SignOfX::NegativeX {
        t6.conj();
    }

    t5.frob(&f, 4);
    t3.mul(&t5);

    let mut t0 = t2.clone();
    t0.conj();
    t6.mul(&t0);

    t5 = t6.clone();
    t5.frob(&f, 3);

    t3.mul(&t5);
    t5 = t6.pow(&mut x);
    t6 = t5.pow(&mut x);

    if ecp::SIGN_OF_X == SignOfX::NegativeX {
        t5.conj();
    }

    t0 = t5.clone();
    t0.frob(&f, 2);
    t3.mul(&t0);
    t0 = t6.clone();
    t0.frob(&f, 1);

    t3.mul(&t0);
    t5 = t6.pow(&mut x);

    if ecp::SIGN_OF_X == SignOfX::NegativeX {
        t5.conj();
    }
    t2.frob(&f, 7);

    t5.mul(&t7);
    t3.mul(&t2);
    t3.mul(&t5);

    r.mul(&t3);

    r.reduce();
    return r;
}
------



use std::time::SystemTime;
use std::time::UNIX_EPOCH;
use super::big;
use super::big::Big;
use super::ecp;
use super::ecp::ECP;
use super::ecp4::ECP4;
use super::fp24::FP24;
use super::fp8::FP8;
use super::pair192;
use super::rom;
use crate::hash256::HASH256;
use crate::hash384::HASH384;
use crate::hash512::HASH512;
use crate::rand::RAND;
use super::*;
use crate::test_utils::*;
