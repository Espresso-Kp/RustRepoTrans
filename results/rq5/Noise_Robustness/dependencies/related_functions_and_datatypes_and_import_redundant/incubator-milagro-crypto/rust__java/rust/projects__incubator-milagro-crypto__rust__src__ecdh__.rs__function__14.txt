pub fn cbc_iv0_encrypt(k: &[u8], m: &[u8]) -> Vec<u8> {
    // AES CBC encryption, with Null IV and key K
    // Input is from an octet string m, output is to an octet string c
    // Input is padded as necessary to make up a full final block
    let mut a = AES::new();
    let mut fin = false;
    let mut c: Vec<u8> = Vec::new();

    let mut buff: [u8; 16] = [0; 16];

    a.init(aes::CBC, k.len(), k, None);

    let mut ipt = 0;
    let mut i;
    loop {
        i = 0;
        while i < 16 {
            if ipt < m.len() {
                buff[i] = m[ipt];
                i += 1;
                ipt += 1;
            } else {
                fin = true;
                break;
            }
        }
        if fin {
            break;
        }
        a.encrypt(&mut buff);
        for j in 0..16 {
            c.push(buff[j]);
        }
    }

    // last block, filled up to i-th index

    let padlen = 16 - i;
    for j in i..16 {
        buff[j] = padlen as u8
    }

    a.encrypt(&mut buff);

    for j in 0..16 {
        c.push(buff[j]);
    }
    a.end();
    c
}

pub fn hmac(sha: usize, m: &[u8], k: &[u8], olen: usize, tag: &mut [u8]) -> bool {
    // Input is from an octet m
    // olen is requested output length in bytes. k is the key
    // The output is the calculated tag
    let mut b: [u8; 64] = [0; 64]; // Not good
    let mut k0: [u8; 128] = [0; 128];

    if olen < 4 {
        return false;
    }

    let mut lb = 64;
    if sha > 32 {
        lb = 128
    }

    for i in 0..lb {
        k0[i] = 0
    }

    if k.len() > lb {
        hashit(sha, k, 0, None, 0, &mut b);
        for i in 0..sha {
            k0[i] = b[i]
        }
    } else {
        for i in 0..k.len() {
            k0[i] = k[i]
        }
    }

    for i in 0..lb {
        k0[i] ^= 0x36
    }
    hashit(sha, &k0[0..lb], 0, Some(m), 0, &mut b);

    for i in 0..lb {
        k0[i] ^= 0x6a
    }
    hashit(sha, &k0[0..lb], 0, Some(&b[0..sha]), olen, tag);

    return true;
}

fn intto_bytes(n: usize, b: &mut [u8]) {
    let mut i = b.len();
    let mut m = n;
    while m > 0 && i > 0 {
        i -= 1;
        b[i] = (m & 0xff) as u8;
        m /= 256;
    }
}

pub fn ecpsvdp_dh(s: &[u8], wd: &[u8], z: &mut [u8]) -> isize {
    let mut res = 0;
    let mut t: [u8; EFS] = [0; EFS];

    let mut sc = Big::from_bytes(&s);

    let mut W = ECP::from_bytes(&wd);
    if W.is_infinity() {
        res = ERROR
    }

    if res == 0 {
        let r = Big::new_ints(&rom::CURVE_ORDER);
        sc.rmod(&r);
        W = W.mul(&sc);
        if W.is_infinity() {
            res = ERROR;
        } else {
            W.getx().to_bytes(&mut t);
            for i in 0..EFS {
                z[i] = t[i]
            }
        }
    }
    res
}

pub fn kdf2(sha: usize, z: &[u8], p: Option<&[u8]>, olen: usize, k: &mut [u8]) {
    // NOTE: the parameter olen is the length of the output K in bytes
    let hlen = sha;
    let mut lk = 0;

    let mut cthreshold = olen / hlen;
    if olen % hlen != 0 {
        cthreshold += 1
    }

    for counter in 1..=cthreshold {
        let mut b: [u8; 64] = [0; 64];
        hashit(sha, z, counter, p, 0, &mut b);
        if lk + hlen > olen {
            for i in 0..(olen % hlen) {
                k[lk] = b[i];
                lk += 1
            }
        } else {
            for i in 0..hlen {
                k[lk] = b[i];
                lk += 1
            }
        }
    }
}

pub fn key_pair_generate(rng: Option<&mut RAND>, s: &mut [u8], w: &mut [u8]) -> isize {
    let res = 0;
    let mut sc: Big;
    let G = ECP::generator();

    let r = Big::new_ints(&rom::CURVE_ORDER);

    if let Some(mut x) = rng {
        sc = Big::randomnum(&r, &mut x);
    } else {
        sc = Big::from_bytes(&s);
        sc.rmod(&r);
    }

    sc.to_bytes(s);

    let WP = G.mul(&sc);

    WP.to_bytes(w, false); // To use point compression on public keys, change to true

    res
}

pub struct RAND {
    ira: [u32; RAND_NK], /* random number...   */
    rndptr: usize,
    borrow: u32,
    pool_ptr: usize,
    pool: [u8; 32],
}

pub const EFS: usize = big::MODBYTES as usize;

pub const AESKEY: usize = 16;

pub const EGS: usize = big::MODBYTES as usize;

pub fn kdf1(sha: usize, z: &[u8], olen: usize, k: &mut [u8]) {
    // NOTE: the parameter olen is the length of the output K in bytes
    let hlen = sha;
    let mut lk = 0;

    let mut cthreshold = olen / hlen;
    if olen % hlen != 0 {
        cthreshold += 1
    }

    for counter in 0..cthreshold {
        let mut b: [u8; 64] = [0; 64];
        hashit(sha, z, counter, None, 0, &mut b);
        if lk + hlen > olen {
            for i in 0..(olen % hlen) {
                k[lk] = b[i];
                lk += 1
            }
        } else {
            for i in 0..hlen {
                k[lk] = b[i];
                lk += 1
            }
        }
    }
}
pub struct RAND {
    ira: [u32; RAND_NK], /* random number...   */
    rndptr: usize,
    borrow: u32,
    pool_ptr: usize,
    pool: [u8; 32],
}
------

use super::big;
use super::big::Big;
use super::ecp;
use super::ecp::ECP;
use super::rom;
use crate::aes;
use crate::aes::AES;
use crate::hash256::HASH256;
use crate::hash384::HASH384;
use crate::hash512::HASH512;
use crate::rand::RAND;
use super::*;
use crate::test_utils::*;
use crate::types::CurveType;
