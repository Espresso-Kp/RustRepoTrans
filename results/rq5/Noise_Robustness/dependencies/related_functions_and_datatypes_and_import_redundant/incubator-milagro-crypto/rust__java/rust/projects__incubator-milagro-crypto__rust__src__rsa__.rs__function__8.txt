fn hashit(sha: usize, a: Option<&[u8]>, n: isize, w: &mut [u8]) {
    if sha == SHA256 {
        let mut h = HASH256::new();
        if let Some(x) = a {
            h.process_array(x);
        }
        if n >= 0 {
            h.process_num(n as i32)
        }
        let hs = h.hash();
        for i in 0..sha {
            w[i] = hs[i]
        }
    }
    if sha == SHA384 {
        let mut h = HASH384::new();
        if let Some(x) = a {
            h.process_array(x);
        }
        if n >= 0 {
            h.process_num(n as i32)
        }
        let hs = h.hash();
        for i in 0..sha {
            w[i] = hs[i]
        }
    }
    if sha == SHA512 {
        let mut h = HASH512::new();
        if let Some(x) = a {
            h.process_array(x);
        }
        if n >= 0 {
            h.process_num(n as i32)
        }
        let hs = h.hash();
        for i in 0..sha {
            w[i] = hs[i]
        }
    }
}

pub fn mgf1(sha: usize, z: &[u8], olen: usize, k: &mut [u8]) {
    let hlen = sha;

    let mut j = 0;
    for i in 0..k.len() {
        k[i] = 0
    }

    let mut cthreshold = olen / hlen;
    if olen % hlen != 0 {
        cthreshold += 1
    }
    for counter in 0..cthreshold {
        let mut b: [u8; 64] = [0; 64];
        hashit(sha, Some(z), counter as isize, &mut b);

        if j + hlen > olen {
            for i in 0..(olen % hlen) {
                k[j] = b[i];
                j += 1
            }
        } else {
            for i in 0..hlen {
                k[j] = b[i];
                j += 1
            }
        }
    }
}

pub const RFS: usize = (big::MODBYTES as usize) * ff::FFLEN;


pub fn kdf1(sha: usize, z: &[u8], olen: usize, k: &mut [u8]) {
    // NOTE: the parameter olen is the length of the output K in bytes
    let hlen = sha;
    let mut lk = 0;

    let mut cthreshold = olen / hlen;
    if olen % hlen != 0 {
        cthreshold += 1
    }

    for counter in 0..cthreshold {
        let mut b: [u8; 64] = [0; 64];
        hashit(sha, z, counter, None, 0, &mut b);
        if lk + hlen > olen {
            for i in 0..(olen % hlen) {
                k[lk] = b[i];
                lk += 1
            }
        } else {
            for i in 0..hlen {
                k[lk] = b[i];
                lk += 1
            }
        }
    }
}
pub struct DBig {
    pub w: [Chunk; big::DNLEN],
}
------

use super::big;
use super::ff;
use super::ff::FF;
use crate::hash256::HASH256;
use crate::hash384::HASH384;
use crate::hash512::HASH512;
use crate::rand::RAND;
use super::*;
use crate::test_utils::*;
