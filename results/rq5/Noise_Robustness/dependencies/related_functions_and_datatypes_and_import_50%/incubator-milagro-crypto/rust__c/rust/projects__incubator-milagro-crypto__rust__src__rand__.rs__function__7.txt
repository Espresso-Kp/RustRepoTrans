fn sirand(&mut self, seed: u32) {
        let mut m: u32 = 1;
        let mut sd = seed;
        self.borrow = 0;
        self.rndptr = 0;
        self.ira[0] ^= sd;
        for i in 1..RAND_NK {
            /* fill initialisation vector */
            let inn = (RAND_NV * i) % RAND_NK;
            self.ira[inn] ^= m; /* note XOR */
            let t = m;
            m = sd.wrapping_sub(m);
            sd = t;
        }
        for _ in 0..10000 {
            self.sbrand();
        } /* "warm-up" & stir the generator */
    }
pub fn process(&mut self, byt: u8) {
        /* process the next message byte */
        let cnt = ((self.length[0] / 32) % 16) as usize;
        self.w[cnt] <<= 8;
        self.w[cnt] |= (byt & 0xFF) as u32;
        self.length[0] += 8;
        if self.length[0] == 0 {
            self.length[1] += 1;
            self.length[0] = 0
        }
        if (self.length[0] % 512) == 0 {
            self.transform()
        }
    }
pub fn hash(&mut self) -> [u8; HASH_BYTES] {
        // pad message and finish - supply digest
        let mut digest: [u8; 32] = [0; 32];
        let len0 = self.length[0];
        let len1 = self.length[1];
        self.process(0x80);
        while (self.length[0] % 512) != 448 {
            self.process(0)
        }
        self.w[14] = len1;
        self.w[15] = len0;
        self.transform();
        for i in 0..32 {
            // convert to bytes
            digest[i] = ((self.h[i / 4] >> (8 * (3 - i % 4))) & 0xff) as u8;
        }
        self.init();
        return digest;
    }
pub struct RAND {
    ira: [u32; RAND_NK], /* random number...   */
    rndptr: usize,
    borrow: u32,
    pool_ptr: usize,
    pool: [u8; 32],
}
------


use crate::hash256::HASH256;
