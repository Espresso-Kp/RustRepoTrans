fn hashit(sha: usize, a: Option<&[u8]>, n: isize, w: &mut [u8]) {
    if sha == SHA256 {
        let mut h = HASH256::new();
        if let Some(x) = a {
            h.process_array(x);
        }
        if n >= 0 {
            h.process_num(n as i32)
        }
        let hs = h.hash();
        for i in 0..sha {
            w[i] = hs[i]
        }
    }
    if sha == SHA384 {
        let mut h = HASH384::new();
        if let Some(x) = a {
            h.process_array(x);
        }
        if n >= 0 {
            h.process_num(n as i32)
        }
        let hs = h.hash();
        for i in 0..sha {
            w[i] = hs[i]
        }
    }
    if sha == SHA512 {
        let mut h = HASH512::new();
        if let Some(x) = a {
            h.process_array(x);
        }
        if n >= 0 {
            h.process_num(n as i32)
        }
        let hs = h.hash();
        for i in 0..sha {
            w[i] = hs[i]
        }
    }
}
pub const RFS: usize = (big::MODBYTES as usize) * ff::FFLEN;
------


use super::big;
use super::ff;
use super::ff::FF;
use crate::hash256::HASH256;
use crate::hash384::HASH384;
use crate::hash512::HASH512;
use crate::rand::RAND;
use super::*;
use crate::test_utils::*;
