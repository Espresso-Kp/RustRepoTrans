fn sirand(&mut self, seed: u32) {
        let mut m: u32 = 1;
        let mut sd = seed;
        self.borrow = 0;
        self.rndptr = 0;
        self.ira[0] ^= sd;
        for i in 1..RAND_NK {
            /* fill initialisation vector */
            let inn = (RAND_NV * i) % RAND_NK;
            self.ira[inn] ^= m; /* note XOR */
            let t = m;
            m = sd.wrapping_sub(m);
            sd = t;
        }
        for _ in 0..10000 {
            self.sbrand();
        } /* "warm-up" & stir the generator */
    }
fn fill_pool(&mut self) {
        let mut sh = HASH256::new();
        for _ in 0..128 {
            sh.process((self.sbrand() & 0xff) as u8)
        }
        let w = sh.hash();
        for i in 0..32 {
            self.pool[i] = w[i]
        }
        self.pool_ptr = 0;
    }
pub fn new() -> HASH256 {
        let mut nh = HASH256 {
            length: [0; 2],
            h: [0; 8],
            w: [0; 64],
        };
        nh.init();
        return nh;
    }
pub struct RAND {
    ira: [u32; RAND_NK], /* random number...   */
    rndptr: usize,
    borrow: u32,
    pool_ptr: usize,
    pool: [u8; 32],
}
------


use crate::hash256::HASH256;
